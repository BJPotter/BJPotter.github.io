---
title: java类的加载机制
tag: java
---

>Java类加载机制是Java虚拟机（JVM）的核心组成部分之一，负责在运行时加载、链接和初始化类。通俗的来讲就是每个.java文件经过javac编译工具编译后生成.class文件，类加载机制就是把这些.class文件中的二进制读到内存中，并对数据进行链接（验证、准备、解析）和初始化，初始化完成后，会在方法区保存一份该类的元数据，同时在堆中创建一个与之对应的`Class`对象，该`Class`对象包含了该类的相关信息。

# 类的生命周期

加载（Loading）-> 验证（Verification）-> 准备（Preparation）-> 解析（Resolution）-> 初始化（Initialization）-> 使用（Usage）-> 卸载（unloading）

1.加载指将字节码文件加载到JVM

2.验证指是否符合JVM虚拟机的规范

3.准备指给静态变量分配内存空间，并设置置默认初始值

4.解析指将类的符号引用转换为直接引用，让虚拟机可以找到对应的内存地址

5.初始化指对静态代码块和静态变量进行初始化操作

6.使用指可以被程序其他的类调用或者说直接引用

7.卸载指在java虚拟机中，如果某个类不再使用，那就认为这个类是无用的，可以被卸载。

# 类什么时候会加载

1.创建类的实例：当程序中使用`new`关键字创建类的实例时，对应的类会被加载。例如：

```java
MyClass obj = new MyClass();
```

2.**访问类的静态变量或静态方法**：当程序中访问类的静态变量或静态方法时，对应的类也会被加载。例如：

```java
MyClass.staticMethod();
```

3.**通过反射动态加载类**：通过Java的反射机制，可以在运行时动态加载类。例如：**

```java
Class.forName("com.example.MyClass");
```

4.**启动应用程序时的入口类加载**：当启动Java应用程序时，会指定一个入口类，该入口类会被加载并执行`main()`方法。这也会触发入口类所依赖的其他类的加载。

5.**继承**：当一个类继承了另一个类时，子类的加载会导致父类也被加载，除非父类已经被加载过。

6.**实现接口**：当一个类实现了某个接口时，接口中定义的常量会被加载。

# 类的加载过程

<img src="https://telegraph-image-2ni.pages.dev/file/2dded58d88ad824bb04c3.png" style="zoom:33%;" />

类的加载过程有五个阶段，其中验证、准备、解析这个子阶段属于链接阶段。下面详细说下，类的加载过程的每个阶段

1.**加载**：将类的字节码被加载到JVM中。包括从文件系统或者网络中读取.class文件，并将其转换为内存中的二进制数据。在加载阶段，还会为类创建一个`java.lang.Class`对象。

2.**验证**：确保类的字节码符合JVM规范，不会导致安全问题或运行时异常。

3.**准备**：为类的静态变量分配内存空间，并设置默认初始值。

4.**解析**：将类中的符号引用转换为直接引用，使得虚拟机能够找到对应的内存地址。

5.**初始化**：在初始化阶段，执行类的静态初始化器（static initializer）和静态变量初始化。静态初始化器是类中的静态代码块，用于初始化类的静态成员变量或执行其他静态初始化操作。





# 类加载器

> 在**加载**阶段，类加载器通过类的全限定名，获取该类字节流数据。

1.**启动类加载器（Bootstrap Class Loader）：**负责加载jre\lib 目录下的jar，由C++实现，不是ClassLoader子类。

2.**拓展类加载器（Extension Class Loader）：**负责加载Java平台中扩展功能的一些jar包，包括jre\lib\ext 目录中 jar包。由Java代码实现。

3.**应用程序类加载器（Application Class Loader）：**我们自己开发的应用程序，就是由它进行加载的，负责加载ClassPath路径下所有jar包。

4.**自定义类加载器（Custom Class Loader）**：可以加载任何类，包括Java标准库中的类、第三方库中的类以及自己编写的类。其加载范围和方式可以根据需求进行灵活定制。

<img src="https://telegraph-image-2ni.pages.dev/file/e1208860284124c277d23.png" style="zoom: 50%;" />





# 双亲委派模型

>简单说就是爹能干的，儿子肯定不干，就是任何一个类加载器在接到一个类的加载请求时，都会先让其父类进行加载，只有父类无法加载（或者没有父类）的情况下，才尝试自己加载。

1. **安全性（Security）**：双亲委派模型可以确保Java核心类库不会被替换或篡改，从而提高了Java程序的安全性。由于Java核心类库由启动类加载器加载，且无法被覆盖，因此不容易受到恶意攻击。
2. **避免类的重复加载（Avoidance of Duplicate Loading）**：双亲委派模型可以避免同一个类被不同的类加载器加载多次，从而节省了内存空间并减少了资源浪费。
3. **统一标准（Standardization）**：双亲委派模型提供了一个统一的类加载机制，使得Java应用程序具有一致的行为。无论是在Java虚拟机的实现上，还是在开发Java应用程序时，都能够遵循同样的加载规则，减少了不必要的复杂性和混乱。
4. **类的隔离性（Isolation）**：双亲委派模型通过委派链的方式实现了类的隔离，每个类加载器只负责加载自己能够访问到的类，从而有效地隔离了不同模块或组件的类，防止了类之间的相互干扰和冲突。
5. **性能优化（Performance Optimization）**：双亲委派模型在加载类时会先检查父类加载器是否已经加载过该类，如果已经加载过，则直接返回已加载的类，从而减少了重复加载和搜索的时间，提高了加载性能。

# 自定义类加载器

自定义类加载器的好处：

1. **动态更新（Dynamic Updating）**：自定义类加载器可以实现动态更新类的功能。例如，当应用程序运行时，可以检测到新的类文件并加载，从而实现热部署或动态扩展应用程序的功能。
2. **类的加密解密（Class Encryption and Decryption）**：自定义类加载器可以在加载类文件时进行解密操作，从而保护类文件的安全性。通过在加载过程中实现解密逻辑，可以防止类文件被恶意篡改或者盗用。
3. **加载非标准文件格式（Loading Non-Standard File Formats）**：自定义类加载器可以加载非标准的类文件格式，例如从数据库、网络或者自定义的存储介质中加载类文件。
4. **从特定位置加载类（Loading Classes from Specific Locations）**：自定义类加载器可以从特定的位置加载类文件，例如从特定的目录、JAR文件或者远程服务器加载类文件。
5. **实现类加载策略（Implementing Class Loading Strategies）**：自定义类加载器可以根据特定的策略加载类文件，例如按需加载、按版本加载或者按条件加载。
6. **解决类加载冲突（Resolving Class Loading Conflicts）**：自定义类加载器可以解决类加载冲突问题，例如当多个模块中存在相同类名但不同版本的类文件时，可以使用自定义类加载器实现类隔离和版本管理。
7. **实现类加载的权限控制（Implementing Class Loading Permissions）**：自定义类加载器可以实现对类加载的权限控制，例如根据用户身份或者访问权限加载不同的类文件。
8. **实现类的热替换（Implementing Class Hot Swapping）**：自定义类加载器可以实现类的热替换功能，即在运行时替换正在使用的类，而不需要重启应用程序。

>下面我们使用自定义的类加载器加载指定的类，并通过反射调用类的方法。

```java
package com.example;

import java.io.*;
import java.lang.reflect.Method;

public class CustomClassLoader extends ClassLoader{
    // 定义加载类的路径
    private String classPath;

    public CustomClassLoader(){}

    public CustomClassLoader(String classPath) {
        this.classPath = classPath;
    }
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // 读取指定路径下的类文件的二进制数据
            byte[] data = loadClassData(name);
            // 调用defineClass方法将二进制数据转换为Class对象
            return defineClass(name, data, 0, data.length);
        } catch (Exception e) {
            throw new ClassNotFoundException("Class " + name + " not found.", e);
        }
    }
    // 加载类文件的二进制数据
    private byte[] loadClassData(String name) throws IOException {
        String fileName = classPath + File.separatorChar + name.replace('.', File.separatorChar) + ".class";
        try (InputStream inputStream = new FileInputStream(fileName);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            int len;
            byte[] buffer = new byte[4096];
            while ((len = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, len);
            }
            return outputStream.toByteArray();
        }
    }
    public static void main(String[] args) throws Exception {
        // 自定义类加载器实例化
        CustomClassLoader classLoader = new CustomClassLoader("D:\\Project\\JAVA\\src\\com.example.CustomClassLoader.class");
        // 使用自定义类加载器加载指定类
        Class<?> clazz = classLoader.loadClass("com.example.CustomClassLoader");
        // 创建实例
        Object instance = clazz.newInstance();
        // 调用方法
        Method method = clazz.getMethod("sayHello");
        method.invoke(instance);
    }
    public void sayHello(){
        System.out.println("say hello");
    }
}
```



# 类加载器的作用域

> 类加载器的作用域（Scope）指的是类加载器加载类的可见范围和生命周期管理。类加载器的作用域决定了类的可见性、类的隔离性以及类的生命周期。

1. **可见性（Visibility）**：每个类加载器实例都有自己的加载路径和类加载命名空间，它只能看到自己加载的类和其父类加载器加载的类。因此，类加载器的可见性决定了哪些类对于特定的类加载器是可见的。
2. **隔离性（Isolation）**：类加载器的隔离性确保了每个类加载器实例加载的类相互之间是隔离的，即同一个类在不同的类加载器实例中被加载时，会被认为是不同的类。这种隔离性保护了应用程序的安全性和稳定性，防止不同模块或组件之间的类产生冲突和干扰。
3. **生命周期管理（Lifecycle Management）**：类加载器的生命周期管理包括类加载器的创建、使用和销毁。在Java应用程序中，类加载器的生命周期通常与应用程序的生命周期相对应。例如，在应用程序启动时创建类加载器实例，在应用程序结束时销毁类加载器实例。
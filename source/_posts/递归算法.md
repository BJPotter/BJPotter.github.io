---
title: 递归算法的7个最佳实践
description: 递归算法是在算法中反复使用的一种方法，其特点是一个函数直接或间接地调用了自己。递归算法能够用简洁的代码来解决复杂问题，如分治算法、搜索算法、排序算法等。下面提供7个常见递归算法的Java实现例子：
date: 2018-03-04
tag: 
- 算法
- 递归
---

# 阶乘算法

>阶乘函数是一个常见的递归例子。在计算一个正整数的阶乘时，我们可以不断地将问题简化为计算一个更小整数的阶乘。事实上，n! = n * (n-1)!。

```java
public class Factorial {
    public static long factorial(int n) {
        return (n == 1) ? 1 : n * factorial(n - 1);
    }
    public static void main(String[] args) {
        System.out.println(factorial(10));
    }
}
```

# 斐波那契数列

>斐波那契数列指的是这样一个数列：0, 1, 1, 2, 3, 5, 8, 13, .... 其中，第0项是0，第1项是1，后面每项都是其前两项之和。

```java
public static int fibonacci(int n) {
    if (n <= 0) { // 基本情况
        return 0;
    } else if (n == 1) { // 基本情况
        return 1;
    } else { // 递归情况
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

# 二分搜索

>二分搜索算法是一个在有序数组中查找特定元素的快速方法，通过不断地将数组分成两半来缩小搜索范围。

```java
public static int binarySearch(int[] array, int low, int high, int key) {
    if (high < low) {
        return -1; // 基本情况，未找到元素
    }

    int mid = low + (high - low) / 2;

    if (array[mid] > key) {
        return binarySearch(array, low, mid - 1, key); // 递归搜索左半部分
    } else if (array[mid] < key) {
        return binarySearch(array, mid + 1, high, key); // 递归搜索右半部分
    } else {
        return mid; // 基本情况，找到元素
    }
}
```

# 归并排序

>归并排序是一种有效的排序算法，运用分治法原理，将数组分成两半进行排序，大致分为分解、解决和合并三个步骤。

```java
public static void mergeSort(int[] array, int left, int right) {
    if (left < right) { // 判断是否存在可分割的子数组
        int middle = (left + right) / 2;
        
        mergeSort(array, left, middle); // 递归排序左半部分
        mergeSort(array, middle + 1, right); // 递归排序右半部分
        
        merge(array, left, middle, right); // 合并两个排序好的子数组
    }
}

public static void merge(int[] array, int left, int middle, int right) {
    // 合并子数组的实现代码...
}
```

# 快速排序

>一个基于分治法的排序算法。它通过一个基准值将数组分为两部分，数组中小于基准值的元素和大于或等于基准值的元素。

```java
public static void quickSort(int[] array, int low, int high) {
    if (low < high) {
        int pi = partition(array, low, high);

        quickSort(array, low, pi - 1);  // 递归排序基准值左边的元素
        quickSort(array, pi + 1, high); // 递归排序基准值右边的元素
    }
}

private static int partition(int[] array, int low, int high) {
    // 分区实现：选择最后一个元素作为基准值，然后进行分区...
    // 分区实现的代码...
}
```

# 深度优先搜索（DFS）

>深度优先搜索是图和树结构中的一种算法。它向深处探索每一条路径，直到找到解决方案或达到非解决分支的结束点。

```java
public static void dfs(Node node) {
    if (node == null) return; // 基本情况
    // 访问节点...
    for (Node child : node.children) {
        dfs(child); // 递归访问子节点
    }
}
```



# 汉诺塔问题

>这是一个经典的递归问题，目标是将所有的盘子从一个柱子移动到另一个柱子，遵守特定规则。

```java
public static void moveDisks(int n, char fromPeg, char toPeg, char auxPeg) {
    if (n == 1) {
        System.out.println("Move disk 1 from peg " + fromPeg + " to peg " + toPeg);
        return;
    }
    moveDisks(n - 1, fromPeg, auxPeg, toPeg); // 把上面的n-1个盘子从开始柱移动到辅助柱
    System.out.println("Move disk " + n + " from peg " + fromPeg + " to peg " + toPeg);
    moveDisks(n - 1, auxPeg, toPeg, fromPeg); // 把这些盘子从辅助柱子移动到目标柱
}
```

>在所有这些情况中，记住要设计出明确的递归结束条件以避免无限递归和可能的栈溢出错误，并考虑递归造成的性能问题，尤其在递归调用次数很多的情况下。在必要时，可以用迭代方法或动态规划等技术来提高性能。

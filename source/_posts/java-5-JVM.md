---
title: java基础-JVM
tag:
- java
---

# JVM基础

## 什么是JVM

Java虚拟机（Java Virtual Machine，简称JVM）是Java语言的一大亮点，它负责执行Java字节码，使得Java程序可以在任何安装了JVM的设备上运行，实现了“写一次，到处运行”（Write Once, Run Anywhere）的目标。

## JVM的作用

**加载代码**：从文件系统或网络中加载.class文件。

**验证代码**：确保字节码的正确性和安全性。

**执行代码**：将字节码转换为机器码执行。

**管理内存**：包括堆内存、栈内存和方法区等，负责内存分配和垃圾回收。

## JVM的组成

JVM主要由四大部分组成：ClassLoader（类加载器），Runtime Data Area（运行时数据区，内存分区），Execution Engine（执行引擎），Native Interface（本地库接口）

<img src="https://telegraph-image-2ni.pages.dev/file/71410e7a433e5800d904e.png" style="zoom:55%;" />



### 工作流程

类加载器负责将字节码文件加载到运行时数据区域，由于字节码是JVM定义的一套指令集，底层操作系统不认识，需要特定的编译器也就是执行引擎翻译成操作系统的认识的指令交给CPU去执行，如果这个过程涉及到调用了c++/c语言的给java编写的接口，会通过本地接口调用本地库去执行。

### ClassLoader

ClassLoader 负责加载字节码文件即 class 文件，class 文件在文件开头有特定的文件标示，并且 ClassLoader 只负责class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。

### Execution Engine

执行引擎，也叫 Interpreter。Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 JVM 指令集翻译为操作系统指令集。

### Native Interface

负责调用本地接口的。他的作用是调用不同语言的接口给 JAVA 用，他会在 Native Method Stack 中记录对应的本地方法，然后调用该方法时就通过 Execution Engine 加载对应的本地 lib。（现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。）

### Runtime Data Area

Runtime Data Area 是JVM在执行Java 程序时使用的内存区域，分为五部分：Stack（虚拟机栈），Heap（堆），Method Area（方法区），PC Register（程序计数器），Native Method Stack（本地方法栈）。

## 运行时数据区

1. **方法区（Method Area）**：存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等数据，方法区是线程共享的。
2. **堆（Heap）**：所有对象实例和数组都在堆中分配内存，堆是线程共享的，是GC主要管理的区域。
3. **虚拟机栈（Java Virtual Machine Stack）**：存放每个线程的栈帧（方法调用过程中的局部变量表、操作数栈、方法返回地址等）。
4. **本地方法栈（Native Method Stack）**：为本地方法服务，与虚拟机栈类似。
5. **程序计数器（Program Counter Register）**：当前线程执行的字节码的行号指示器。

# 类的加载机制

>Java类加载机制是Java虚拟机（JVM）的核心组成部分之一，负责在运行时加载、链接和初始化类。通俗的来讲就是每个.java文件经过javac编译工具编译后生成.class文件，类加载机制就是把这些.class文件中的二进制读到内存中，并对数据进行链接（验证、准备、解析）和初始化，初始化完成后，会在方法区保存一份该类的元数据，同时在堆中创建一个与之对应的`Class`对象，该`Class`对象包含了该类的相关信息。

## 类的生命周期

加载（Loading）-> 验证（Verification）-> 准备（Preparation）-> 解析（Resolution）-> 初始化（Initialization）-> 使用（Usage）-> 卸载（unloading）

1.加载指将字节码文件加载到JVM

2.验证指是否符合JVM虚拟机的规范

3.准备指给静态变量分配内存空间，并设置置默认初始值

4.解析指将类的符号引用转换为直接引用，让虚拟机可以找到对应的内存地址

5.初始化指对静态代码块和静态变量进行初始化操作

6.使用指可以被程序其他的类调用或者说直接引用

7.卸载指在java虚拟机中，如果某个类不再使用，那就认为这个类是无用的，可以被卸载。

## 类什么时候会加载

1.创建类的实例：当程序中使用`new`关键字创建类的实例时，对应的类会被加载。

```java
MyClass obj = new MyClass();
```

2.**访问类的静态变量或静态方法**：当程序中访问类的静态变量或静态方法时，对应的类也会被加载。

```java
MyClass.staticMethod();
```

3.**通过反射动态加载类**：通过Java的反射机制，可以在运行时动态加载类。

```java
Class.forName("com.example.MyClass");
```

4.**启动应用程序时的入口类加载**：当启动Java应用程序时，会指定一个入口类，该入口类会被加载并执行`main()`方法。这也会触发入口类所依赖的其他类的加载。

5.**继承**：当一个类继承了另一个类时，子类的加载会导致父类也被加载，除非父类已经被加载过。

6.**实现接口**：当一个类实现了某个接口时，接口中定义的常量会被加载。

## 类的加载过程

<img src="https://telegraph-image-2ni.pages.dev/file/2dded58d88ad824bb04c3.png" style="zoom:33%;" />

类的加载过程有五个阶段，其中验证、准备、解析这个子阶段属于链接阶段。下面详细说下，类的加载过程的每个阶段

1.**加载**：将类的字节码被加载到JVM中。包括从文件系统或者网络中读取.class文件，并将其转换为内存中的二进制数据。在加载阶段，还会为类创建一个`java.lang.Class`对象。

2.**验证**：确保类的字节码符合JVM规范，不会导致安全问题或运行时异常。

3.**准备**：为类的静态变量分配内存空间，并设置默认初始值。

4.**解析**：将类中的符号引用转换为直接引用，使得虚拟机能够找到对应的内存地址。

5.**初始化**：在初始化阶段，执行类的静态初始化器（static initializer）和静态变量初始化。静态初始化器是类中的静态代码块，用于初始化类的静态成员变量或执行其他静态初始化操作。





## 类加载器

> 在**加载**阶段，类加载器通过类的全限定名，获取该类字节流数据。

1.**启动类加载器（Bootstrap Class Loader）：**负责加载jre\lib 目录下的jar，由C++实现，不是ClassLoader子类。

2.**拓展类加载器（Extension Class Loader）：**负责加载Java平台中扩展功能的一些jar包，包括jre\lib\ext 目录中 jar包。由Java代码实现。

3.**应用程序类加载器（Application Class Loader）：**我们自己开发的应用程序，就是由它进行加载的，负责加载ClassPath路径下所有jar包。

4.**自定义类加载器（Custom Class Loader）**：可以加载任何类，包括Java标准库中的类、第三方库中的类以及自己编写的类。其加载范围和方式可以根据需求进行灵活定制。

<img src="https://telegraph-image-2ni.pages.dev/file/e1208860284124c277d23.png" style="zoom: 50%;" />





## 双亲委派模型

>当一个类加载器需要加载某个类时,它首先会把这个请求委托给父类加载器去执行,只有当父类加载器无法完成这个请求时,子类加载器才会尝试自己去加载。从启动类开始到自定义加载器结束，如果都没找到，抛出classnotfound

**优点**

1. 避免类的重复加载

当一个类加载器收到类加载请求时,它首先会把这个请求委托给父类加载器,只有当父类加载器无法完成这个请求时,子类加载器才会尝试自己去加载。这种方式避免了同一个类被重复加载多次。

2. 保证Java核心库的安全

Java核心库中的类是由启动类加载器加载的,它们处于Java应用程序的最顶层。如果子类加载器可以随意加载自己的实现,就可能会覆盖Java核心库中的实现,这可能会导致Java应用程序运行时出现严重的问题。

3. 实现类的一致性

由于所有类加载器都会首先委托给启动类加载器,因此相同名称的类在整个Java应用程序中都是同一个类。这种机制保证了Java应用程序的类加载是一致的

**缺点**

1. 无法实现热部署
2. 法加载动态生成的类

## 自定义类加载器

自定义类加载器的好处：

1. **动态更新（Dynamic Updating）**：自定义类加载器可以实现动态更新类的功能。例如，当应用程序运行时，可以检测到新的类文件并加载，从而实现热部署或动态扩展应用程序的功能。
2. **类的加密解密（Class Encryption and Decryption）**：自定义类加载器可以在加载类文件时进行解密操作，从而保护类文件的安全性。通过在加载过程中实现解密逻辑，可以防止类文件被恶意篡改或者盗用。
3. **加载非标准文件格式（Loading Non-Standard File Formats）**：自定义类加载器可以加载非标准的类文件格式，例如从数据库、网络或者自定义的存储介质中加载类文件。
4. **从特定位置加载类（Loading Classes from Specific Locations）**：自定义类加载器可以从特定的位置加载类文件，例如从特定的目录、JAR文件或者远程服务器加载类文件。
5. **实现类加载策略（Implementing Class Loading Strategies）**：自定义类加载器可以根据特定的策略加载类文件，例如按需加载、按版本加载或者按条件加载。
6. **解决类加载冲突（Resolving Class Loading Conflicts）**：自定义类加载器可以解决类加载冲突问题，例如当多个模块中存在相同类名但不同版本的类文件时，可以使用自定义类加载器实现类隔离和版本管理。
7. **实现类加载的权限控制（Implementing Class Loading Permissions）**：自定义类加载器可以实现对类加载的权限控制，例如根据用户身份或者访问权限加载不同的类文件。
8. **实现类的热替换（Implementing Class Hot Swapping）**：自定义类加载器可以实现类的热替换功能，即在运行时替换正在使用的类，而不需要重启应用程序。

>下面我们使用自定义的类加载器加载指定的类，并通过反射调用类的方法。

```java
public class CustomClassLoader extends ClassLoader{
    // 定义加载类的路径
    private String classPath;

    public CustomClassLoader(){}

    public CustomClassLoader(String classPath) {
        this.classPath = classPath;
    }
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // 读取指定路径下的类文件的二进制数据
            byte[] data = loadClassData(name);
            // 调用defineClass方法将二进制数据转换为Class对象
            return defineClass(name, data, 0, data.length);
        } catch (Exception e) {
            throw new ClassNotFoundException("Class " + name + " not found.", e);
        }
    }
    // 加载类文件的二进制数据
    private byte[] loadClassData(String name) throws IOException {
        String fileName = classPath + File.separatorChar + name.replace('.', File.separatorChar) + ".class";
        try (InputStream inputStream = new FileInputStream(fileName);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            int len;
            byte[] buffer = new byte[4096];
            while ((len = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, len);
            }
            return outputStream.toByteArray();
        }
    }
    public static void main(String[] args) throws Exception {
        // 自定义类加载器实例化
        CustomClassLoader classLoader = new CustomClassLoader("D:\\Project\\JAVA\\src\\com.example.CustomClassLoader.class");
        // 使用自定义类加载器加载指定类
        Class<?> clazz = classLoader.loadClass("com.example.CustomClassLoader");
        // 创建实例
        Object instance = clazz.newInstance();
        // 调用方法
        Method method = clazz.getMethod("sayHello");
        method.invoke(instance);
    }
    public void sayHello(){
        System.out.println("say hello");
    }
}
```

## 类加载器的作用域

> 类加载器的作用域（Scope）指的是类加载器加载类的可见范围和生命周期管理。类加载器的作用域决定了类的可见性、类的隔离性以及类的生命周期。

1. **可见性（Visibility）**：每个类加载器实例都有自己的加载路径和类加载命名空间，它只能看到自己加载的类和其父类加载器加载的类。因此，类加载器的可见性决定了哪些类对于特定的类加载器是可见的。
2. **隔离性（Isolation）**：类加载器的隔离性确保了每个类加载器实例加载的类相互之间是隔离的，即同一个类在不同的类加载器实例中被加载时，会被认为是不同的类。这种隔离性保护了应用程序的安全性和稳定性，防止不同模块或组件之间的类产生冲突和干扰。
3. **生命周期管理（Lifecycle Management）**：类加载器的生命周期管理包括类加载器的创建、使用和销毁。在Java应用程序中，类加载器的生命周期通常与应用程序的生命周期相对应。例如，在应用程序启动时创建类加载器实例，在应用程序结束时销毁类加载器实例。

# JVM内存管理

JVM 在执行 Java 程序的过程中会将其管理的内存划分为若干个不同的数据区域如下图所示，这些区域各自有不同的不同的用途、创建和销毁时间，有的区域随着虚拟机进程启动而存在，而有的则依赖用户线程的启动和结束而建立和销毁；有些区域是属于线程私有，而另外一些区域则是是线程共享。

<img src="https://telegraph-image-2ni.pages.dev/file/30ebc304a08f58253b845.png" style="zoom:50%;" />	

## 线程私有的内存区域

### 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间（可能位于cpu的寄存器，有待确认），可以看做是当前字节码指令执行的行号指示器，记录了当前正在执行的虚拟机字节码指令地址。每个线程都有各自独立的程序计数器，注意如果正在执行的是 Native方法，则程序计数器为空（Undifined），并且 JVM 规范中并没有对程序计数器定义 **OutOfMemoryError** 异常。

### 虚拟机栈（VM Stack）

虚拟机栈也是线程私有的，它描述的是**Java方法执行的内存模型**：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。

1. **局部变量表(Local Variable Table)**:存放了编译期可知的各种数据类型(基本数据类型、对象引用)包括方法参数和方法内部定义的局部变量
2. **操作数栈(Operand Stack)**:方法执行过程中的中间计算结果会临时存储在这里方法调用时，参数会从这里弹出，计算结果也会被压入这里
3. **动态链接(Dynamic Linking)**:每个方法都有一个指向运行时常量池中该方法的符号引用用于支持方法的动态绑定
4. **方法出口信息**:一个方法的返回地址用于在方法执行完毕后返回到方法被调用的位置

虚拟机栈帧中，局部变量表是比较为人所熟知的，也就是平常所说的“栈”，局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

虚拟机栈有两种异常情况：

1. **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度，特别是方法的递归调用时
2. **OutOfMemoryError**：虚拟机栈无法满足线程所申请的空间需求，即使经过动态扩展仍然无法满足时抛出

### 本地方法栈（Native Method Stack）

本地方法栈与虚拟机栈相似，不过服务于本地方法，有些虚拟机将这两个区域合二为一。本地方法栈中抛出异常的情况与虚拟机栈相同。

## 线程共享的内存区域

### 堆（Heap）

通常来说，堆是Java虚拟机管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建，堆的作用就是存储对象实例。

堆也是垃圾收集器所管理的主要区域，因此很多时候也被称作**GC堆**。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，因此堆还可以被细分为：**新生代和老年代**。再继续细分可以分为：**Eden空间、From Survivor空间、To Survivor空间等**，从内存分配的角度来看，线程共享的堆中还可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。

堆可以是物理上不连续的空间，只要逻辑上是连续的即可，-Xmx和-Xms参数可以控制堆的最大和最小值。

堆的空间大小不满足时将抛出OutOfMemoryError异常。

### 方法区（Method Area）

用于存储已被虚拟机加载的类的元数据信息包括类、方法、字段等各方面的信息以及常量、静态变量、JIT编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆）。

方法区同样会抛出OutOfMemoryError异常。

在方法区中有一部分区域用来存储编译期产生的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。这里需要说明一点，常量并不是只能在编译期产生，运行期间也会产生新的常量并被发在常量池中，如 String 类的 intern() 方法。

**运行时常量池**

1. 字面量(Literal)

- 字符串字面量,如"abc"
- 基本类型字面量,如1、2L、3.14f等

2. 符号引用(Symbolic References)

- 类和接口的完全限定名(fully qualified name)
- 字段的名称和描述符(descriptor)
- 方法的名称和描述符
- 方法句柄和方法类型

3. 动态链接

常量池中的符号引用在加载和链接过程中会被替换为直接引用。

4. 运行时解析

常量池中的符号引用在第一次被使用时,才会去解析。解析后的直接引用存储在常量池中。

5. 性能优化

常量池可以存储一些经常使用的对象,以提高性能。如String的intern()方法就是利用常量池来缓存字符串对象。

## 直接内存

注意直接内存不属于虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，其主要用于 JDK1.4 引入的基于通道(Channel)和缓冲区(Buffer)的 NIO 类，可以避免在 Native 堆和 Java 堆之间来回复制数据从而提高性能。该部分内存分配不受 Java 堆内存大小的限制，但是肯定也受限于机器硬件内存的限制。

# GC垃圾回收机制

GC（垃圾收集）是一个早于 Java 的概念，诞生于 1960 年的 Lisp 语言当时就使用了内存动态分配和垃圾收集技术，经过半个世纪发展，这项技术已经发展很成熟。之所以还要去探究 GC 和内存分配，是因为当程序万一出现了内存溢出、内存泄漏等问题的时候，当垃圾收集成为系统高并发性能瓶颈的时候，我们需要有针对性的对 JVM 自动化的内存分配和垃圾回收策略实施必要的监控和调整。

## 哪些内存需要回收

内存模型中程序计数器、本地方法栈、虚拟机栈都属于线程私有，生命周期随线程消失就消失了，堆和方法区是资源共享的，这两块是主要进行垃圾回收的地方。

### 判断对象是否存活的方法

当一个对象不存活的时候，我们认为这个对象可以进行回收了，有两种方法判断对象是否存活：

**引用计数法：** 给对象添加一个引用计数器，每当有一个地方引用计数器就加 1，引用失效时计数器就减 1，当计数器为0的时候这个对象就可以被回收了。缺点是无法解决循环引用问题，导致内存泄漏。

**可达性分析法（HotSpot 默认）：** 从一组称为"根"（roots）的对象开始，通过一系列的对象引用关系，找到所有能从根对象访问到的其他对象，然后将这些对象标记为活跃对象（live objects）。未被标记的对象则可以被视为垃圾对象，可以被安全地回收。

+ **标记阶段（Mark Phase）：** 从预定义的根集合（如全局变量、调用栈、寄存器等）出发，递归或迭代地遍历所有能够通过引用访问到的对象，并将它们标记为活跃对象。这个过程确保了所有从根对象可达的对象都被标记。
+ **清除阶段（Sweep Phase）：** 遍历整个堆（heap），将未被标记的对象视为垃圾对象，进行回收释放其占用的内存空间。清除阶段保证了所有未被标记的对象都是不可达的，可以被安全地回收。

标记阶段可能需要停止应用程序的执行（称为停顿），以便进行全局的对象遍历和标记，这可能会对程序的响应时间和性能造成影响。为了解决这个问题，现代的垃圾回收算法通常会结合多种技术，如增量标记、并发标记等，来减少停顿时间和提高回收效率。

Java中可作为GC Roots的对象：

- 虚拟机栈中引用的对象
- 本地方法栈中Native方法引用的对象
- 方法区中的常量引用的对象



## 垃圾回收算法

### 标记-清除算法（Mark-Sweep）

**工作原理：**

1. **标记阶段（Mark Phase）**：从GC Roots出发，递归或迭代地遍历所有可达对象，并给这些对象加上标记，表示这些对象是活跃的（即正在使用的）。
2. **清除阶段（Sweep Phase）**：遍历整个堆内存，将没有被标记的对象视为垃圾对象（即不再使用的对象），然后将这些垃圾对象所占据的内存释放掉，以便后续的内存分配使用。

**优缺点：**

- **优点**：简单直观，能有效回收不再使用的内存对象。
- **缺点**：可能产生内存碎片，停顿时间长，不适合对实时性要求高的应用。

### 复制算法（Coping）

**工作原理：**

1. **分区内存**：将可用内存空间分为两个区域（通常是半空间），一个用于活动对象，另一个用于不活动对象。
2. **标记和复制**：
   - **标记阶段**：从根集（如全局变量、活动函数调用链等）开始，标记所有从根集可达的活动对象。
   - **复制阶段**：将标记过的活动对象复制到另一半空间，同时更新所有指向这些对象的引用。未被复制的对象被视为不再被引用，可以被视为垃圾。
3. **空间交换**：完成复制后，原来的半空间被整个释放，而复制得到的新半空间则成为新的活动空间。

**优缺点：**

- **优点：** 高效的垃圾回收，碎片问题减少
- **缺点：** 它需要额外的一半内存空间来进行复制操作，使用内存比较多，以空间换时间的策略



### 标记-整理算法（Mark-Compact）

**工作原理：**

1. **标记阶段（Mark Phase）**：
   - 从根对象（如全局变量、活动栈等）出发，通过可达性分析，标记出所有存活的对象。
   - 使用某种标记方法（通常是通过标记对象上的一个标志位或者位图），将所有可以访问到的对象进行标记，表示这些对象是活跃的。
2. **整理阶段（Compact Phase）**：
   - 在标记阶段完成后，所有未标记的对象被认定为垃圾，可以被回收。
   - 剩余的存活对象可能会在内存中产生碎片化，即存在空闲的小块内存间隔。
   - 在整理阶段，存活的对象被紧凑地移动，以消除这些碎片，使得所有存活对象成为一个连续的内存块。
3. **移动对象**：
   - 整理阶段需要将存活对象移动到新的位置，通常是从内存低地址向高地址移动。
   - 移动过程中需要更新所有引用这些对象的指针，确保指向正确的地址。

**优缺点：**

- **优点：** 能够有效地消除内存中的碎片，减少内存的浪费。
- **缺点：** 由于需要移动对象，可能会造成一定的性能开销。

### 分代收集算法

新生代采用复制算法，老年代采用标记整理算法

## 什么时候回收

首先来看看 HotSpot VM 都有哪些类型的 GC：

- Partial GC(局部 GC): 并不收集整个 GC 堆的模式
  - Young GC/Minor GC: 只收集 young gen 的 GC。
  - Old GC/Major GC: 只收集old gen的GC。只有垃圾收集器CMS的concurrent collection 是这个模式
  - Mixed GC: 收集整个young gen 以及部分old gen的GC。只有垃圾收集器 G1有这个模式
- Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式

### Full GC触发条件

- 显式的调用 System.gc()：尽量避免在代码中显式调用此方法，让虚拟机自己去管理它的内存
- serial GC 中，老年代内存剩余已经小于之前年轻代晋升老年代的平均大小，则进行 Full GC；而在 CMS 等并发收集器中则是每隔一段时间检查一下老年代内存的使用量，超过一定比例时进行 Full GC 回收。

### Yong GC / Minor GC触发条件：

当 Eden 区的空间耗尽时 Java 虚拟机便会触发一次 Minor GC 来收集新生代的垃圾，存活下来的对象，则会被送到 Survivor 区。简单说就是当新生代的Eden区满的时候触发 Minor GC。

###   

新生代共有两个Survivor区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivor 区是空的。当发生 Minor GC时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制(此处采用标记 - 复制算法)到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。from 与 to 只是两个指针，它们变动的，to 指针指向的 Survivor 区是空的。

### Survivor 区对象晋升位老年代对象的条件

Java 虚拟机会记录 Survivor 区中的对象在 from 和 to 之间一共被来回复制了几次。如果一个对象被复制的次数为 15 (对应虚拟机参数 -XX:+MaxTenuringThreshold)，那么该对象将被晋升为至老年代；另外，如果单个 Survivor 区已经被占用了 50% (对应虚拟机参数: -XX:TargetSurvivorRatio)，那么较高复制次数的对象也会被晋升至老年代。

## hotspot 都有哪些垃圾收集器

- 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发（Concurrent）：指 **用户线程与垃圾收集线程** 同时执行，用户程序在继续运行。

### 垃圾回收器对比

| 类型       | 垃圾回收器        | 特点                   |
| ---------- | ----------------- | ---------------------- |
| **新生代** | Serial            | 频繁回收、停顿时间短   |
|            | ParNew            |                        |
|            | Parallel Scavenge |                        |
| **老年代** | Serial Old        | 回收频率低、停顿时间长 |
|            | CMS               |                        |
|            | Parallel Old      |                        |

## 新生代收集器

新生代对象一般都是朝生夕灭，每次都会有超过 95% 的对象被回收，因此更适合使用复制算法进行回收。

### Serial 收集器

Serial（串行）收集器是最基本、最悠久的采用复制算法的新生代收集器，它在进行垃圾收集时会 Stop The World。是 HotSpot 虚拟机运行在 Client 模式下的默认的新生代收集器。

### ParNew 收集器

ParNew 收集器是 Serial 收集器的多线程版本，也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为与 Serial 收集器完全相同。需要注意的是这里的并行并不是与用户线程并行，而是会有多个线程执行 GC，此时仍然是 Stop The World 的状态。

ParNew 是 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，除了 Serial 收集器外，目前只有它能和 CMS 收集器（Concurrent Mark Sweep）配合工作，需要注意的是 ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器有更好的效果，因为存在线程切换的开销。

### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一个并行的采用复制算法的多线程新生代收集器。它的特点是会根据当前系统的运行情况收集性能监控信息，动态调整新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）等参数以提供最合适的停顿时间或者最大的吞吐量，即 GC 自适应的调节策略（GC Ergonomics）。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。

注意 Parallel Scavenge 收集器无法与 CMS 收集器配合使用，所以在 JDK 1.6 推出 Parallel Old 之前，如果新生代选择 Parallel Scavenge 收集器，老年代只有 Serial Old 收集器能与之配合使用。

## 老年代收集器

老年代一般需要回收的对象不会占到太大的比例，因此基本都是用标记 - 整理的方式。

### Serial Old 收集器

Serial 收集器的老年代版本，单线程采用 “标记 - 整理”（Mark-Compact）算法。也主要是用于 Client 模式下的虚拟机。

### Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记 - 整理” 算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现的,非常符合互联网站或者B/S系统的服务端上的Java应用，响应速度快。

CMS收集器工作流程：

- 初始标记（CMS initial mark）：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要"Stop The World"。
- 并发标记（CMS concurrent mark）：进行 GC Roots Tracing 的过程，在整个过程中耗时最长。
- 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要"Stop The World"。
- 并发清除（CMS concurrent sweep）

可以看到过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

因此 CMS 的优点是：并发收集、低停顿。它的缺点是由于采用并发所以对 CPU 资源非常敏感，其次它采用标记-清除的算法会导致的空间碎片

## G1 收集器

G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点：

- **并行与并发** G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 “Stop The World” 停顿时间。
- **分代收集** 分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果。
- **空间整合** G1 从整体来看是基于 “标记 - 整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的。
- **可预测的停顿** 降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型

## 如何选择收集器

1. 吞吐量优先： 如果应用程序对吞吐量要求较高,可以选择并行收集器(Parallel Collector)

2. 响应时间优先： 如果应用程序对响应时间要求较高,可以选择CMS收集器或G1收集器

3. 内存使用情况： 如果内存小于100MB,可以选择串行收集器，如果内存大于20GB,建议选择G1收集器

4. CPU使用情况：如果CPU资源充足,可以选择并行收集器

# 其他知识

## HotSpot对象的创建过程

1. 类加载和准备：当程序中使用new关键字创建对象时,首先会触发类的加载和准备阶段。

   - 类加载阶段会将类的二进制数据加载到内存,并对数据进行校验、解析和初始化等操作。

   - 类准备阶段会为类的静态变量分配内存,并设置默认初始值。

2. 内存分配：对象创建的内存空间主要在Java堆中进行分配。具体过程如下:

   + 在Eden区分配足够大小的内存块。

   + 如果Eden区内存不足,则触发一次Minor GC,将存活对象复制到Survivor区。

   + 如果Survivor区内存也不足,则将对象直接分配到老年代。

3. 对象初始化：对象内存分配完成后,会执行<init>方法对对象进行初始化。这个过程包括:

   + 为对象设置对象头,包括哈希码、GC分代年龄等信息。

   + 执行构造函数中的代码,对对象的成员变量进行初始化。

4. 对象访问：对象创建完成后,程序就可以通过句柄或直接指针访问该对象的实例数据了。

## Java中都有哪些引用类型不会被回收

- **强引用**：不会被GC回收。

```java
Object obj = new Object(); // 这就是一个强引用
```

强引用是使用最普遍的引用类型。只要强引用还存在,垃圾回收器就永远不会回收掉被引用的对象。即使内存不足,JVM也宁愿抛出OutOfMemoryError也不会去回收具有强引用的对象。

- **软引用**：描述一些有用但并非必需的对象,内存不足时会被回收。

```java
SoftReference<Object> softRef = new SoftReference<>(new Object());
```

- **弱引用**：弱引用也是用于描述非必需对象的一种引用类型,在GC时会被回收。

```java
WeakReference<Object> weakRef = new WeakReference<>(new Object());
```

- **虚引用**：无法通过引用访问对象，仅用于监控对象的回收。

```java
PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), queue);
```

## 大对象直接进入老年代

避免在新生代频繁复制大对象，减少内存复制开销。

# JVM调优

## 说一下JVM调优的工具？

常用的JVM调优工具包括：
- **jstat**：监控JVM内存和垃圾回收情况。
- **jmap**：生成堆转储快照，分析内存使用情况。
- **jstack**：生成线程快照，分析线程状态。
- **VisualVM**：图形化界面监控JVM性能。

## 常用的JVM调优的参数都有哪些？

### 常用参数

- **-Xms**：设置初始堆大小。
- **-Xmx**：设置最大堆大小。
- **-Xmn**：设置新生代大小。
- **-XX:PermSize**：设置初始永久代大小（JDK 8前）。
- **-XX:MaxPermSize**：设置最大永久代大小（JDK 8前）。
- **-XX:MetaspaceSize**：设置初始元空间大小（JDK 8后）。
- **-XX:MaxMetaspaceSize**：设置最大元空间大小（JDK 8后）。

### 垃圾回收器参数

1. 设置垃圾收集器

在Java应用程序启动时,可以通过JVM参数来指定使用哪种垃圾收集器。常用的设置方式如下:

- 串行收集器: `-XX:+UseSerialGC`
- 并行收集器: `-XX:+UseParallelGC`
- CMS收集器: `-XX:+UseConcMarkSweepGC`
- G1收集器: `-XX:+UseG1GC`

2. 调整垃圾收集器参数

- 设置年轻代和老年代的比例: `-XX:NewRatio=n`
- 设置年轻代中Eden区与Survivor区的比例: `-XX:SurvivorRatio=n`
- 设置并行收集器的线程数: `-XX:ParallelGCThreads=n`
- 设置CMS收集器的触发时机: `-XX:CMSInitiatingOccupancyFraction=n`
- 设置G1收集器的young/old代比例: `-XX:G1NewSizePercent=n`

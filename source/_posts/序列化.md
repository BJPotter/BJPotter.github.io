---
title: 序列化
---

# 什么是序列化和反序列化

>将对象转化成字节流，可以将其保存在文件系统、数据库或其他持久性存储介质中，以实现数据的持久化存储。
>
>简单说就是：
>
>- **序列化**：把对象转换成二进制字节流的过程
>- **反序列化**：将在序列化过程中所生成的二进制字节流转换成对象的过程

<img src="https://telegraph-image-2ni.pages.dev/file/1fff0f9d66252dbcbf26e.png" style="zoom:33%;" />



# 为什么要用序列化呢，序列化的好处

1. **持久化数据**：序列化允许将对象转换为字节流或其他格式，从而可以将其保存在文件系统、数据库或其他持久性存储介质中。通过序列化，数据可以在不同的应用程序执行之间进行持久化，并且在程序重新启动后仍然可用。
2. **数据交换**：序列化使得数据可以在网络上传输或在进程之间进行通信。通过将对象序列化为字节流或其他格式，可以轻松地在不同的系统或平台之间交换数据。
3. **跨平台兼容性**：序列化可以帮助解决不同操作系统、编程语言或硬件架构之间的兼容性问题。通过序列化，数据可以以通用格式存储，从而使得不同系统之间的数据交换更加简单。
4. **对象传递**：在分布式系统中，序列化可以使得对象可以在网络上传输并在远程系统上重建。这对于远程过程调用（RPC）和分布式系统通信非常有用。
5. **数据备份和恢复**：通过序列化，可以将应用程序的状态保存为数据流，并在需要时进行恢复。这对于实现备份和恢复功能非常有用，以及在应用程序发生崩溃或异常情况下保存数据状态。

# 序列化协议在哪层

osi的7层模型中表示层主要做数据处理包括编解码、加解密、压缩和解压缩，包括对用户数据进行转换成二进制流，正好对应序列化协议。

# 序列化协议有哪些

+ JDK 自带的序列化，要实现 `java.io.Serializable`接口
+ Kryo：运行速度快，生成的二进制流体积小，Hive和Storm中用
+ Protobuf: 谷歌出的，支持多种语言，跨平台的，但是操作复杂。
+ Hessian: 跨语言，高效的二进制序列化

# 如何实现序列化呢

>例如：JDK 自带的序列化，只需实现 `java.io.Serializable`接口即可

```java
public class User implements Serializable {
    private static final long serialVersionUID = 1807122061950651809L;
    private String username;
    private String password;
}
```

**serialVersionUID 有什么作用？**

序列化号 `serialVersionUID` 属于版本控制的作用。反序列化时，会检查 `serialVersionUID` 是否和当前类的 `serialVersionUID` 一致。如果 `serialVersionUID` 不一致则会抛出 `InvalidClassException` 异常。强烈推荐每个序列化类都手动指定其 `serialVersionUID`，如果不手动指定，那么编译器会动态生成默认的 `serialVersionUID`。

**如果有些字段不想进行序列化怎么办？**

对于不想进行序列化的变量，可以使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

**JDK自带序列化的问题**

1.**不支持跨语言** : 只支持java语言开发的程序调用

2.**性能差**：序列化之后的字节数组体积较大，导致传输成本加大。

3.**存在安全问题**：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。






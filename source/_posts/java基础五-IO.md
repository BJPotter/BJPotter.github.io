---
title: java基础-io
tag:
- java
typora-root-url: ./..
---

# 什么是IO

## 冯诺依曼结构

根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。

<img src="https://telegraph-image-2ni.pages.dev/file/b412f6130798df7f5dcf8.jpg" style="zoom: 33%;" />

我们的IO主要指的是输入设备和输出设备，输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。

## IO的具体流程

一个进程的地址空间划分为用户空间和内核空间，内核空间负责系统级别的资源操作（文件管理、进程通信、内存管理等等）。如果要进行IO。必须依赖内核空间，用户空间（应用程序空间）没有权限进行IO操作，如果想要进行IO操作，只能发起系统调用请求操作系统，由操作系统调用内核完成具体的IO操作，（**应用程序实际上只发起了IO操作的调用，具体IO的执行是由操作系统的内核来完成的。**）

## IO步骤总结

1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间。

### 磁盘IO的数据流向

在读操作时，数据从磁盘设备流向内核空间，然后再流向用户空间；在写操作时，数据从用户空间流向内核空间，然后再流向磁盘设备。

### 网络IO数据流向

在接收数据时，数据从网络设备流向内核空间，再流向用户空间（应用程序的内存空间）；在发送数据时，数据从应用程序的内存流向内核空间，最后流向网络设备。





# Java中3种常见 IO 模型

## BIO

同步阻塞IO，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

## NIO

同步非阻塞IO中，应用程序发起read调用后，如果内核中没有就绪的数据，内核会立即返回一个错误，应用程序继续执行其他操作，这是非阻塞的；如果内核中数据已经就绪，当应用程序需要再次发起read调用来读取数据时是阻塞的。（**阻不阻塞取决于内核数据是否准备就绪，不阻塞可以执行其他操作，阻塞的话只能等待**）

**缺点：**不断轮询询问内核空间是否准备就绪，浪费CPU性能

## AIO

应用程序发起read调用后，内核会立即返回，不需要阻塞等待数据的准备和拷贝，内核在后台会继续处理这些IO，并在IO完成后通过事件或者回调机制通知应用程序。

**回调函数（Callback）**：在发起异步I/O请求时，一般会传递一个回调函数给操作系统。一旦I/O操作完成，操作系统就会调用这个回调函数，以此来通知应用程序。这个回调函数通常会包含操作的结果，比如操作是否成功，读取或写入的数据量等信息。

**事件通知（Event Notification）**：操作系统提供一种机制，允许应用程序询问或者等待一个或多个I/O操作的完成通知。例如Linux的epoll，BSD的kqueue，Java的NIO(Non-blocking I/O)库等。应用程序可以在一次查询中得知多个I/O操作是否完成，这在处理大量并发连接时，可以提高效率。

# BIO

>BIO是同步阻塞IO，当一个线程进行IO操作的时候，它会阻塞到线程执行完毕。以流的方式处理数据，基于字符流和字节流操作的



## 字符流和字节流的区别

<img src="/images/IO.drawio.svg" style="zoom:70%;" />

在java中IO指的是input和output，在java中分为输入流和输出流，根据处理数据不同的单位分为字节流和字符流。字节流以字节（8位）为单位进行数据处理，如图片、视频，字符流是以字符进行为单位进行数据处理，如文本。

+ 处理单位：字节流以字节为单位，字符流以字符为单位。
+ 用途：字节流可以处理所有类型的数据，字符流只能处理字符类型的数据。
+ 处理中文字符：字节流可能会出现乱码的情况，字符流按字符处理，不会出现乱码

## 字节流

### InputStream

`InputStream`用于从源头（通常是文件）读取数据（字节信息）到内存中，`java.io.InputStream`抽象类是所有字节输入流的父类。

`read()`：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 `-1` ，表示文件结束。

`read(byte b[ ])` : 从输入流中读取一些字节存储到数组 `b` 中。如果数组 `b` 的长度为零，则不读取。如果没有可用字节读取，返回 `-1`。如果有可用字节读取，则最多读取的字节数最多等于 `b.length` ， 返回读取的字节数。这个方法等价于 `read(b, 0, b.length)`。

`read(byte b[], int off, int len)`：在`read(byte b[ ])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。

`skip(long n)`：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。

`available()`：返回输入流中可以读取的字节数。

`close()`：关闭输入流释放相关的系统资源。

### OutputStream

`write(int b)`：将特定字节写入输出流。

`write(byte b[ ])` : 将数组`b` 写入到输出流，等价于 `write(b, 0, b.length)` 。

`write(byte[] b, int off, int len)` : 在`write(byte b[ ])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。

`flush()`：刷新此输出流并强制写出所有缓冲的输出字节。

`close()`：关闭输出流释放相关的系统资源。

## 字符流

字节流对字符的处理（特别是中文）会出现乱码，字符流默认采用unicode编码，避免这个情况。

**字符流的优点：**

1.可以处理中文字符

2.支持unicode编码，也可以根据构造函数自定义编码集

3.可以实现读一行，写一行

### Reader

`read()` : 从输入流读取一个字符。

`read(char[] cbuf)` : 从输入流中读取一些字符，并将它们存储到字符数组 `cbuf`中，等价于 `read(cbuf, 0, cbuf.length)` 。

`read(char[] cbuf, int off, int len)`：在`read(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。

`skip(long n)`：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。

`close()` : 关闭输入流并释放相关的系统资源。

### Writer

`write(int c)` : 写入单个字符。

`write(char[] cbuf)`：写入字符数组 `cbuf`，等价于`write(cbuf, 0, cbuf.length)`。

`write(char[] cbuf, int off, int len)`：在`write(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。

`write(String str)`：写入字符串，等价于 `write(str, 0, str.length())` 。

`write(String str, int off, int len)`：在`write(String str)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。

`append(CharSequence csq)`：将指定的字符序列附加到指定的 `Writer` 对象并返回该 `Writer` 对象。

`append(char c)`：将指定的字符附加到指定的 `Writer` 对象并返回该 `Writer` 对象。

`flush()`：刷新此输出流并强制写出所有缓冲的输出字符。

`close()`:关闭输出流释放相关的系统资源。

## 缓冲流

IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。

### 字节缓冲流

`BufferedInputStream` 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。

`BufferedOutputStream` 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率

### 字符缓冲流

`BufferedReader` （字符缓冲输入流）和 `BufferedWriter`（字符缓冲输出流）类似于 `BufferedInputStream`（字节缓冲输入流）和`BufferedOutputStream`（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。

## 转换流

转换流主要是InputStreamReader和OutputStreamWriter,InputStreamReader 用于将字节输入流转换为字符输入流，其中 OutputStreamWriter 用于将字节输出流转换为字符输出流。使用转换流可以在一定程度上避免乱码，还可以指定输入输出所使用的字符集。

```java
InputStreamReader isr = new InputStreamReader(new FileInputStream("example.txt"), "UTF-8);
OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("example.txt"), "UTF-8");
```

# NIO

>NIO是同步非阻塞IO，它是非阻塞、面向缓冲、基于通道的IO,可以通过少量的线程处理多个连接，相关的类在java.nio包下，主要有三大核心channel（通道）、buffer（缓存）、selector（选择器）

## NIO和BIO的区别

+ 数据单位：BIO以流的方式处理数据，NIO是以块的方式处理数据
+ 是否阻塞：BIO是阻塞的，NIO是非阻塞的
+ 操作方式：BIO是以字符流或者字节流处理数据，NIO是基于通道和缓冲进行数据处理

## NIO核心组件

NIO的核心组件是Channel、Buffer、Selector,如下图所示

<img src="/images/NIO.png" style="zoom:43%;" />

### 数据流向

>缓冲区是数据的临时存储区，通道是连接数据源和缓冲区的桥梁，负责数据的实际传输。
>
>读操作时，数据从数据源流向缓冲区。
>
>写操作时，数据从缓冲区流向目标位置。

![](/images/NIO.drawio.svg)

### 缓冲区

所有数据的读写都是通过缓冲区进行的，缓冲区实质上是一块可以写数据和读取数据的内存，这块内存被包装成 NIO Buffer 对象，并提供一组方法，用来方便地操作这块内存。

- 容量(Capacity)：缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定并且不能改变。

- 位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get 或 put 方法更新。

- 限制(Limit)：缓冲区中第一个不应该读取或写入的元素的索引。或者说，你可操作的数据大小（limit - position）。

- 标记(Mark)：一个备忘位置。可以通过 Buffer.mark() 在此位置设置标记，之后可以通过 Buffer.reset() 方法恢复到这个位置。

**操作步骤：**

1. 写数据到Buffer：调用 Buffer.put() 之类的方法写数据。写完后，position 显示最新写入数据的位置。

2. 调用flip()方法：切换Buffer到读模式。读写模式切换是通过 Buffer.flip() 方法完成的，它将 limit 设置为当前 position 的值，position 设置为 0 ，准备读取数据。

3. 从Buffer中读数据：调用 Buffer.get() 读取数据。

4. 调用clear()方法或compact()方法：读完后，调用 Buffer.clear() 或 Buffer.compact() 切换到写模式，准备再次写入。清空缓冲区并不会删除其中的数据，只是所有的状态值(position、limit、mark)都被设定为初始状态。所以看起来它是空的。

### 通道

通道代表了与能够执行 I/O 操作的实体（例如，文件、套接字）的连接。简单来说，任何时候你想读写数据（不论是来自文件、网络还是其他地方）

- 双向性：Java NIO的通道可以同时进行读和写操作，而Java IO流通常都是单向的（InputStream或OutputStream）。

- 非阻塞性：Java NIO的通道可以被配置为非阻塞模式，因此我们可以在异步模式中使用它们。例如，一个线程可以请求写数据到一个通道，但是该线程继续做别的事情，当数据写入成功后，线程将收到通知。

- 可直接访问缓冲区：数据可以直接从缓冲区写入到通道，或者从通道读取到缓冲区。它们之间的连接足够紧密，以至于Java编译器会为其生成优化的代码。

- 通道实现：Java NIO中最重要的通道实现是 FileChannel（用于文件读写），SocketChannel和ServerSocketChannel（用于TCP网络读写）和DatagramChannel（用于UDP网络读写）。

### 选择器

选择器（Selector）是一个特殊的组件，允许一个单一的线程管理多个通道。也就是说，如果你的应用程序有成千上万的开放连接，每个连接都有它的通道，那么你可以用一个单独的线程，使用一个选择器来管理这些通道，而不是为每一个通道都创建一个线程。这就是NIO实现高并发的一种方式，由于创建和切换线程都是相对高昂的操作，所以使用选择器能极大提升效率。

- 多路复用：选择器允许一个单独的线程管理多个通道，或者说“选择”出已经准备好进行I/O操作的通道。这就是NIO中经常提到的“多路复用”。

- 非阻塞式的I/O操作：通过将一或多个通道注册到选择器上，你可以询问选择器是否有准备好的通道，或者更精确的，是否有满足我们关心的事件的通道。

- 选择键（SelectionKey）：当你将通道注册到选择器上时，选择器会返回一个SelectionKey对象，这个对象包含了一些你对之后能发生在注册的通道上面的操作的信息。这是通过对Interest集合进行设置来完成的，最常用的就是SelectionKey.OPREAD（读取操作准备好）和SelectionKey.OPWRITE（写入操作准备好）

- 通道的注册和查询：通常会将通道注册(register)到选择器，然后通过调用选择器的 select()方法，查询准备好的通道。这个方法会阻塞，直到至少有一个通道准备好了你感兴趣的事件。你还可以使用 select(long timeout)方法或 selectNow()方法，前者会在指定时间内等待，后者则不会阻塞。

# 零拷贝

## 什么是零拷贝

传统的数据传输需要数据在用户空间（User Space）和内核空间（Kernel Space）之间进行多次复制操作，这不仅会占用大量CPU，还会增大系统的内存压力。零拷贝减少了两次CPU将数据从内核空间到用户空间的拷贝。

## 零拷贝的实现方式

1. 内存映射文件（MappedByteBuffer）：这是一种将文件或文件的一部分映射到内存中的方式。当映射完成后，你可以直接对映射内存进行操作，任何对内存的修改都会反映到文件上，反之亦然。这种方式避免了Java堆和文件之间的数据拷贝，意味着可以直接对文件进行操作，而不需要在Java堆上创建一个中间缓冲区。

2. 文件通道的传输（transferTo/transferFrom）：这是另一种零拷贝技术，允许我们将一个通道的数据直接传输到另一个通道。传输数据时，数据并没有经过用户空间，而是直接通过内核空间，从而避免了多余的数据复制过程。

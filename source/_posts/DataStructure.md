---
title: 数据结构和算法
description: 学习数据结构和算法的一些基本知识
tag:
- 数据结构
- Algorithm
---

# 基础概念

## 算法定义

> 算法（algorithm）是解决问题的方法和步骤

五大特性：

- **输入**：具有0个或多个输入
- **输出**：具有1个或多个输出
- **有穷性**：算法执行有限个步骤后终止
- **确切性**：算法的每一步都有确切的定义
- **可行性**：每个计算步骤可以在有效的时间内完成

## 数据结构定义

> 数据结构（data structure）是计算机中组织和存储数据的方式

## 数据结构和算法的关系

> 数据结构是组织数据的方式，算法是处理这些数据的方法，二者共同决定了程序的效率和性能。

## 时间复杂度和空间复杂度

### 算法效率如何评估

> 算法设计出来以后，能够正确的解决问题，在正确解决问题的基础下，我们希望解决问题的算法即快又省内存，因此评估算法的效率我们从两个维度看，一个是时间维度，一个是空间维度。

### 什么是时间复杂度

> 算法中的基本操作的执行次数，为算法的时间复杂度。

### 什么是空间复杂度

> 算法在运行过程中临时额外占用存储空间大小的度量。

# 数据结构

## 数据结构的分类

常见的数据结构包括：数组、链表、栈、队列、哈希表、树、堆、图。

## 逻辑结构：

- **线性数据结构**：数组、链表、栈、队列 元素之间是一对一
- **非线性数据结构**：树、堆、图、哈希表 元素之间是一对多或者是多对多

## 物理结构

- **连续存储**：基于数组实现的
- **非连续存储**：基于链表实现的

## 基本数据类型

> 基本数据类型是CPU直接处理的数据类型，以二进制的方式存储在计算机中。一个二进制位就是1比特，一个字节由8个比特组成。
>
> 基本数据类型主要包括：
>
> - 整型：byte、short、int、long
> - 浮点型：float、double
> - 字符型：char
> - 布尔型：true、false

## 编码知识

> 数字是以补码的形式存在计算机中

**原码**：数字二进制位的最高位为符号位，0为正数，1为负数，其余位表示数字的值。

**反码**：正数的反码和原码是一致的，负数的反码是除符号位其余位取反。

**补码**：正数的补码和原码是一致的，负数的补码是在反码的基础上加1。

> **现在的字符编码一般都用UTF-8**

# 数组

## 什么是数组

> 数组是线性结构，将相同类型的元素存储在连续的内存空间中。

## 数组的操作

- **初始化数组**
- **查询操作**
- **插入操作**
- **删除操作**
- **修改操作**
- **遍历操作**
- **数组扩容**

# 链表

## 什么是链表

> 链表是一种线性数据结构，其中的元素通过指针连接，每个元素称为节点。

- **单链表**：每个节点包含数据和指向下一个节点的指针。
- **双链表**：每个节点包含数据、指向下一个节点的指针和指向上一个节点的指针。
- **循环链表**：链表的最后一个节点指向第一个节点，形成一个环。

## 链表的操作

- **初始化链表**
- **查询操作**
- **插入操作**
- **删除操作**
- **修改操作**
- **遍历操作**

# 栈

## 什么是栈

> 栈是一种线性数据结构，遵循后进先出（LIFO）的原则。

## 栈的操作

- **初始化栈**
- **入栈（Push）**
- **出栈（Pop）**
- **查看栈顶元素（Peek）**
- **判断栈是否为空**

## 如何实现栈

- **基于数组实现**
- **基于链表实现**

# 队列

## 什么是队列

> 队列是一种线性数据结构，遵循先进先出（FIFO）的原则。

## 队列的操作

- **初始化队列**
- **入队（Enqueue）**
- **出队（Dequeue）**
- **查看队首元素（Peek）**
- **判断队列是否为空**

## 如何实现队列

- **基于数组实现**
- **基于链表实现**

## 什么是双向队列

> 双向队列是一种线性数据结构，支持从两端进行插入和删除操作。

## 如何实现双向队列

- **基于数组实现**
- **基于链表实现**

# 哈希表

## 什么是哈希表

> 哈希表是一种数据结构，通过哈希函数将键映射到存储位置，以实现快速查找。

## 哈希表的操作

- **插入操作**
- **删除操作**
- **查找操作**

## 哈希表的实现

- **数组加链表**
- **数组加红黑树**

## 哈希冲突

> 当两个不同的键通过哈希函数映射到相同的位置时，称为哈希冲突。

## 哈希算法

- **除留余数法**
- **乘法散列法**
- **平方取中法**

# 树

## 什么是二叉树

> 二叉树是一种树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。

## 二叉树的术语

- **根节点**：树的顶端节点。
- **叶子节点**：没有子节点的节点。
- **内部节点**：有子节点的节点。
- **子树**：一个节点及其所有后代节点组成的树。
- **深度**：从根节点到某个节点的最长路径上的节点数。
- **高度**：从某个节点到叶子节点的最长路径上的节点数。

## 二叉树的基本操作

- **插入操作**
- **删除操作**
- **查找操作**
- **遍历操作**

## 二叉树的类型

- **完全二叉树**：除了最后一层，其他层的节点都被填满，最后一层的节点从左到右依次填充。
- **满二叉树**：每一层的节点数都达到最大值。
- **平衡二叉树**：每个节点的左右子树的高度差不超过1。
- **二叉搜索树（BST）**：左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值。

## 二叉树的遍历

- **前序遍历**：根节点 -> 左子树 -> 右子树
- **中序遍历**：左子树 -> 根节点 -> 右子树
- **后序遍历**：左子树 -> 右子树 -> 根节点
- **层序遍历**：按层次从上到下，从左到右遍历节点

## 如何用数组表示二叉树

> 可以使用数组来表示二叉树，数组的索引从1开始，根节点存储在索引1的位置，左子节点存储在索引2的位置，右子节点存储在索引3的位置，以此类推。

## 什么是二叉搜索树

> 二叉搜索树（BST）是一种特殊的二叉树，左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值。

## 什么是AVL树

> AVL树是一种自平衡二叉搜索树，每个节点的左右子树的高度差不超过1。

# 堆

## 什么是堆

> 堆是一种特殊的树形数据结构，满足堆性质：对于最大堆，任意节点的值大于等于其子节点的值；对于最小堆，任意节点的值小于等于其子节点的值。

## 堆的操作

- **插入操作**
- **删除操作**
- **查找操作**

## 如何建堆

- **插入建堆**
- **删除建堆**

# 图

## 什么是图

> 图是一种非线性数据结构，由顶点和边组成，用于表示对象及其关系。

## 图的操作

- **插入操作**
- **删除操作**
- **查找操作**

## 图的遍历

- **深度优先搜索（DFS）**
- **广度优先搜索（BFS）**

# 搜索算法

## 深度优先搜索（DFS）

> 深度优先搜索是一种遍历或搜索树或图的算法，从根节点开始，沿着每个分支尽可能深地搜索。

- **应用**：迷宫求解、图的连通性检测等。

## 广度优先搜索（BFS）

> 广度优先搜索是一种遍历或搜索树或图的算法，从根节点开始，逐层向外搜索。

- **应用**：最短路径求解、图的连通性检测等。

# 排序算法

## 选择排序

> 选择排序是一种简单的排序算法，每次从未排序部分选择最小（或最大）的元素，放到已排序部分的末尾。

- **时间复杂度**：O(n^2)
- **空间复杂度**：O(1)
- **稳定性**：不稳定

## 冒泡排序

> 冒泡排序是一种简单的排序算法，通过多次遍历数组，每次比较相邻元素并交换，使得较大的元素逐渐“冒泡”到数组末尾。

- **时间复杂度**：O(n^2)
- **空间复杂度**：O(1)
- **稳定性**：稳定

## 插入排序

> 插入排序是一种简单的排序算法，通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

- **时间复杂度**：O(n^2)
- **空间复杂度**：O(1)
- **稳定性**：稳定

## 快速排序

> 快速排序是一种高效的排序算法，通过分治法将数组分为两个子数组，分别排序，然后合并。

- **时间复杂度**：平均O(n log n)，最坏O(n^2)
- **空间复杂度**：O(log n)
- **稳定性**：不稳定

## 归并排序

> 归并排序是一种稳定的排序算法，通过分治法将数组分为两个子数组，分别排序，然后合并。

- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **稳定性**：稳定

## 堆排序

> 堆排序是一种基于堆的数据结构的排序算法，利用堆的性质进行排序。

- **时间复杂度**：O(n log n)
- **空间复杂度**：O(1)
- **稳定性**：不稳定

## 桶排序

> 桶排序是一种线性时间复杂度的排序算法，通过将元素分配到不同的桶中，分别排序，然后合并。

- **时间复杂度**：O(n + k)
- **空间复杂度**：O(n + k)
- **稳定性**：稳定

## 计数排序

> 计数排序是一种线性时间复杂度的排序算法，通过计数每个元素出现的次数，计算每个元素在排序后的位置。

- **时间复杂度**：O(n + k)
- **空间复杂度**：O(n + k)
- **稳定性**：稳定

## 基数排序

> 基数排序是一种线性时间复杂度的排序算法，通过逐位比较元素的各位数字进行排序。

- **时间复杂度**：O(nk)
- **空间复杂度**：O(n + k)
- **稳定性**：稳定

# 算法思想

## 分治算法

> 分治算法是一种将问题分解成更小的子问题，分别解决，然后合并结果的算法。

- **应用**：快速排序、归并排序、二分查找等。

## 回溯算法

> 回溯算法是一种逐步构建解决方案，并在发现当前路径不通时回溯到上一步的算法。

- **应用**：八皇后问题、迷宫求解、数独等。

## 动态规划

> 动态规划是一种将问题分解成更小的子问题，通过保存子问题的解来避免重复计算的算法。

- **应用**：斐波那契数列、最短路径问题、背包问题等。

## 贪心算法

> 贪心算法是一种在每一步选择中都采取当前最优选择的算法，期望通过局部最优解得到全局最优解。

- **应用**：最小生成树、最短路径问题、活动选择问题等。

# 数据结构和算法的应用

## 数组的应用

- **动态数组**：自动扩容的数组，如Java中的ArrayList。
- **二维数组**：用于表示矩阵、图像等二维数据。

## 链表的应用

- **单链表**：用于实现栈、队列等数据结构。
- **双链表**：用于实现双向队列、LRU缓存等。

## 栈的应用

- **函数调用栈**：用于保存函数调用信息。
- **表达式求值**：用于中缀表达式转后缀表达式、计算后缀表达式等。

## 队列的应用

- **任务调度**：用于任务的先来先服务调度。
- **消息队列**：用于异步消息传递。

## 哈希表的应用

- **缓存**：用于快速查找缓存数据。
- **集合操作**：用于实现集合、字典等数据结构。

## 树的应用

- **文件系统**：用于表示文件目录结构。
- **搜索树**：用于实现高效的查找、插入、删除操作。

## 堆的应用

- **优先队列**：用于实现优先级调度。
- **排序算法**：用于堆排序。

## 图的应用

- **社交网络**：用于表示用户关系。
- **路径规划**：用于计算最短路径、最小生成树等。


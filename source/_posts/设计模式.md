---
title: 设计模式
---

## 基于jdbc的策略模式

>当进行数据库连接的时候，可能是mysql，可能是oracle,可能是pg,涉及到数据库的切换。为此采用策略模式进行多数据库切换，只需要选择不同数据库的对应的客户端就行
>
>策略模式原理：
>
>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。
>
>缺点：把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

### 创建策略接口

```java
/**
 * <p>
 * 数据库连接策略接口
 * </p>
 */
public interface StatgeDb {
    public Connection getConnection();
}
```

### Mysql策略实现类

```java
/**
 * <p>
 * Mysql策略实现类
 * </p>
 */
public class MysqlStatge implements StatgeDb{
    /**
     * 具体实现
     * @return
     */
    @Override
    public Connection getConnection() {
        //1.加载驱动
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        //2.获取连接
        Connection con = null;
        try {
            con = DriverManager.getConnection("jdbc:mysql://localhost:3306/switchgame(lf526)?characterEncoding=utf8&serverTimezone=UTC&useSSL=false", "root", "123456");

        } catch (SQLException throwables) {
            System.out.println("获取连接失败");
            throwables.printStackTrace();
        }
        System.out.println("获取连接成功");
        return con;
    }
}
```

### Orcale策略实现类

```java
/**
 * <p>
 * Orcale策略实现类
 * </p>
 */
public class OrcaleStatge implements StatgeDb{
    @Override
    public Connection getConnection() {
        System.out.println("OrcaleStatge连接成功，只做演示，不具体实现");
        return null;
    }
}
```

### Pg策略实现类

```java
/**
 * <p>
 * Pg策略实现类
 * </p>
 */
public class PgStatge implements StatgeDb{
    @Override
    public Connection getConnection() {
        System.out.println("PgStatge连接成功，只做演示，不具体实现");
        return null;
    }
}
```

### 策略模式实现类

>策略模式客户端，只需要创建客户端的时候，传入不同的策略对象，即可调用不同的数据库

```java
/**
 * <p>
 * 策略模式实现类
 * </p>
 */
public class StatgeDbClient {
    StatgeDb statgeDb;
    public StatgeDbClient(StatgeDb statgeDb){
        this.statgeDb = statgeDb;
    }
    public Connection getConnection(){
        return statgeDb.getConnection();
    }
}
```

### 策略模式实现测试类

```java
/**
 * <p>
 * 策略模式实现测试类
 * </p>
 */
public class StatgeDbTest {
    public static void main(String[] args) {
        //对mysql进行连接
        StatgeDbClient statgeDbClient = new StatgeDbClient(new MysqlStatge());
        Connection connection = statgeDbClient.getConnection();
        //对mysql进行连接
        StatgeDbClient orcaleStatge = new StatgeDbClient(new OrcaleStatge());
        Connection connection_orcale = orcaleStatge.getConnection();
        //对mysql进行连接
        StatgeDbClient pgStatge = new StatgeDbClient(new PgStatge());
        Connection connection_pgStatge = pgStatge.getConnection();
    }
}
```

## 代理模式

>执行sql的时候想看下执行的sql语句，此时可以使用代理模式，把需要打印的sql，调用一下打印方法就可以了
>
>代理模式: 为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。

### 创建代理模式接口

```java
/**
 * <p>
 * 代理模式接口
 * </p>
 */
public interface ProxySql {
    void print();
}
```

### 创建真实实现类

```java
/**
 * <p>
 * 代理真实类
 * </p>
 */
public class RealProxySqlImpl implements ProxySql{
    private String sql;
    public RealProxySqlImpl(String sql){
        this.sql = sql;
    }
    @Override
    public void print() {
        System.out.println("execute sql "+this.sql);
    }
}
```

### 创建代理实现类

```java
/**
 * <p>
 * 代理实现类
 * </p>
 */
public class ProxySqlImpl implements ProxySql{
    private RealProxySqlImpl realProxySql;
    private String sql;
    public ProxySqlImpl(String sql){
        this.sql = sql;
    }
    @Override
    public void print() {
        if(realProxySql == null){
            realProxySql = new RealProxySqlImpl(sql);
        }
        realProxySql.print();
    }
}
```

### 测试

>只需要需要打印sql的地方进行调用代理类，本方法打印sql实现比较简单，代理模式可以进行进行事务管理，sql注入的检测等其他高级功能

```java
//读取用户信息
public List<Map<String,String>>getUsers(String username){
 String sql = "select * from user";
 String[] params = null;
 if(username != null) {
  sql = sql + "where username like ?";
  //添加代理类
  ProxySql proxySql = new ProxySqlImpl(sql);
  proxySql.print();
  params = new String[] {"%"+ username + "%"};
}
 return db.getList(sql,params);
}
```

## 单例模式

>它提供了一种创建对象的最佳方式。
>
>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

>懒汉式和饿汉式区别:
>
>实例化方面:懒汉式默认不会实例化，外部什么时候调用什么时候new。饿汉式在类加载的时候就实例化，并目创建单例对象。
>线程安全方面:
>
>1.饿汉式线程安全:在线程还没出现之前就已经实例化了，因此饿汉式线程一定是安全的。
>2.懒汉式线程不安全:因为懒汉式加载是在使用时才会去new实例的，那么你去new的时候是一个动态的过程，是放到方法中实现的。

#### 懒汉式实现方式

```java
/**
 * <p>
 * 单例模式类
 * </p>
 */
public class Singleton {
    /**
     * 懒汉式
     */
    private static DBUtil instance;
    private Singleton (){}
    public static synchronized DBUtil getInstance() {
        if (instance == null) {
            instance = new DBUtil();
        }
        return instance;
    }
}
```

### 饿汉式实现方式

```java
/**
 * <p>
 * 单例模式类
 * </p>
 */
public class Singleton {
    /**
     * 饿汉式
     */
    private static DBUtil instance = new DBUtil();
    private Singleton (){}
    public static DBUtil getInstance() {
        return instance;
    }
}


```

### 使用方式

>每次使用的时候不用每次new创建一个对象，直接去单例里面拿对象

```java
public class SoftTypeService {
	//private DBUtil db = new DBUtil();
	private DBUtil db = Singleton.getInstance();
}    
```

## 模板方法

>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式
>
>Servlet就是一个很好的模板模式的类，只需要继承并且重写他的get、post方法就可以，因为它已经写好了这种模板

#### 自定义一个servlet

```java
/**
 * <p>
 * 自定义模板类
 * </p>
 */
public class ServletHttp extends HttpServlet {
    private static final long serialVersionUID = 1L;

    public ServletHttp() {
        super();
        // TODO Auto-generated constructor stub
    }
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //执行具体的业务逻辑
    }


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }

}
```

### 未自定义前我们的使用方式

```java
@WebServlet("/logout")
public class Logout extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public Logout() {
        super();
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		request.getSession().invalidate();
		response.sendRedirect("index.html");
		
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


```

### 使用我们自定义的servlet模板

```java
/**
 * <p>
 * 模板模式类
 * </p>
 *
 */
@WebServlet("/logout2")
public class ModelLogout extends ServletHttp{
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //执行具体的业务逻辑
        request.getSession().invalidate();
        response.sendRedirect("index.html");
    }
}
```

### 测试方式

```jsp
<%@ page pageEncoding="utf-8"%>
<h1 style="color: red; text-align: center;"></h1>
<body style="background:url(images/b3.jpg);background-size:cover;text-align: center;">
<div align="right">
	<a href="list_user">用户管理</a>&nbsp;&nbsp; 
	<a href="">游戏软件管理</a>&nbsp;&nbsp; 
	<a href="type_list">游戏分类管理</a>&nbsp;&nbsp; 
	<a href="logout">退出系统</a>&nbsp;&nbsp; 换成<a href="logout2">退出系统</a>&nbsp;&nbsp;
</div>
</body>
<hr>
```

## 原型模式

>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。

#### 优点：

>- Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
>- 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

#### 缺点:

>- 需要为每一个类都配置一个 clone 方法
>- clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
>- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

#### 抽象原型类

> Cloneable 接口

#### 具体原型类

>实现抽象原型类的 clone() 方法，它是可被复制的对象。

```java
/**
 * <p>
 * user类
 * </p>
 *
 */
public class User  implements Cloneable{
    Integer id;
    String username;
    String password;
    String salt;
    String ident;
    String telephone;
    String address;

    public User() {
    }

    public User(Integer id, String username, String password, String salt, String ident, String telephone, String address) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.salt = salt;
        this.ident = ident;
        this.telephone = telephone;
        this.address = address;
    }

    public User(String username, String password, String salt, String ident, String telephone, String address) {
        this.username = username;
        this.password = password;
        this.salt = salt;
        this.ident = ident;
        this.telephone = telephone;
        this.address = address;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getSalt() {
        return salt;
    }

    public void setSalt(String salt) {
        this.salt = salt;
    }

    public String getIdent() {
        return ident;
    }

    public void setIdent(String ident) {
        this.ident = ident;
    }

    public String getTelephone() {
        return telephone;
    }

    public void setTelephone(String telephone) {
        this.telephone = telephone;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", salt='" + salt + '\'' +
                ", ident='" + ident + '\'' +
                ", telephone='" + telephone + '\'' +
                ", address='" + address + '\'' +
                '}';
    }

    public Object clone() throws CloneNotSupportedException {
        System.out.println("具体原型复制成功！");
        return (User) super.clone();
    }
}

```

测试方法

```java
/**
 * <p>
 * 原型测试类
 * </p>
 */
public class PrototypeTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        User user = new User();
        User user1 = (User) user.clone();
        System.out.println("obj1==obj2?" + (user == user1));
    }
}
```


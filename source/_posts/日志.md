---
title: 日志框架
tag: 
- 日志
---

# LogBack

Logback 是 Spring Boot 默认的日志框架，功能强大且性能优越。它是由 Log4j 的创始人开发的，提供了更好的配置和更高的性能。

## 配置 Logback

在 Spring Boot 项目中，你可以通过 `logback-spring.xml` 文件来配置 Logback。将该文件放在 `src/main/resources` 目录下。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <!-- 控制台输出 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 日志文件路径 -->
        <file>logs/app.log</file>

        <!-- 滚动策略：按天滚动日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件命名模式 -->
            <fileNamePattern>logs/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <!-- 保留历史日志文件的最大天数 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>

        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 根日志记录器 -->
    <root level="info">
        <appender-ref ref="STDOUT" />
        <appender-ref ref="FILE" />
    </root>

    <!-- 特定包或类的日志记录器 -->
    <logger name="com.example" level="debug" />

</configuration>
```

## 使用日志

在你的代码中使用 SLF4J API 来记录日志

```java
@RestController
@RequestMapping("/api")
public class ExampleController {

    private static final Logger logger = LoggerFactory.getLogger(ExampleController.class);

    @GetMapping("/example")
    public String getExample() {
        logger.info("Handling /example request");
        return "Hello, Logback!";
    }
}
```



# Log4j2

Log4j2 是另一个流行的日志框架，提供了丰富的功能和高性能。你可以选择使用 Log4j2 作为 Spring Boot 项目的日志框架。

## 添加依赖

在 `pom.xml` 文件中添加 Log4j2 依赖。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

## 配置 Log4j2

在 `src/main/resources` 目录下创建 `log4j2-spring.xml` 配置文件。

```xml
<!-- log4j2-spring.xml -->
<Configuration status="WARN">
    <Appenders>
        <!-- 控制台输出 -->
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n"/>
        </Console>

        <!-- 文件输出 -->
        <RollingFile name="File" fileName="logs/app.log" filePattern="logs/app-%d{yyyy-MM-dd}.log">
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n"/>
            <Policies>
                <TimeBasedTriggeringPolicy/>
            </Policies>
        </RollingFile>
    </Appenders>

    <Loggers>
        <!-- 根日志记录器 -->
        <Root level="info">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="File"/>
        </Root>

        <!-- 特定包或类的日志记录器 -->
        <Logger name="com.example" level="debug" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="File"/>
        </Logger>
    </Loggers>
</Configuration>
```

## 使用日志

在你的代码中使用 SLF4J API 来记录日志。

```java
@RestController
@RequestMapping("/api")
public class ExampleController {

    private static final Logger logger = LoggerFactory.getLogger(ExampleController.class);

    @GetMapping("/example")
    public String getExample() {
        logger.info("Handling /example request");
        return "Hello, Log4j2!";
    }
}
```



# SLF4J

SLF4J 是一个简单的日志门面（Facade），它为各种日志框架（如 Logback、Log4j、Log4j2、Java Util Logging 等）提供了统一的接口。SLF4J 本身并不实现日志记录功能，而是通过绑定（Binding）将日志调用委托给具体的日志框架。

## 优点

- **统一接口**：提供统一的日志记录接口，解耦了应用程序和具体的日志框架。
- **灵活性**：可以在不修改代码的情况下切换日志框架，只需更改绑定依赖。
- **简洁性**：简化了日志记录的 API，使得代码更加简洁和易读。

## 案例

使用 SLF4J 的典型示例：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Example {
    private static final Logger logger = LoggerFactory.getLogger(Example.class);

    public static void main(String[] args) {
        logger.info("This is an info message");
        logger.error("This is an error message");
    }
}
```

## SLF4J 和 Logback 的关系

1. **接口与实现**：

   - SLF4J 提供了统一的日志记录接口，而 Logback 是 SLF4J 的一个实现。
   - 通过 SLF4J 的 API 进行日志记录时，实际的日志记录操作由 Logback 执行。

2. **绑定（Binding）**：

   - 使用 SLF4J 时，需要引入一个绑定库（如 `slf4j-logback`），将 SLF4J 的日志调用委托给 Logback。

   - 在 Maven 项目中，可以通过以下依赖来实现绑定：

     ```xml
          <dependency>
              <groupId>org.slf4j</groupId>
              <artifactId>slf4j-api</artifactId>
              <version>1.7.30</version>
          </dependency>
          <dependency>
              <groupId>ch.qos.logback</groupId>
              <artifactId>logback-classic</artifactId>
              <version>1.2.3</version>
          </dependency>
     ```

3. **使用 SLF4J 进行日志记录**：

- 在代码中使用 SLF4J 的 API 进行日志记录，而具体的日志记录操作由 Logback 执行。
- 这种方式使得应用程序与具体的日志框架解耦，可以在不修改代码的情况下切换日志框架。

## SLF4J 和 Log4j2 的关系

1. **接口与实现**：

   - SLF4J 提供了统一的日志记录接口，而 Log4j2 是 SLF4J 的一个实现之一。
   - 通过 SLF4J 的 API 进行日志记录时，实际的日志记录操作可以由 Log4j2 执行。

2. **绑定（Binding）**：

   - 使用 SLF4J 时，需要引入一个绑定库（如 `log4j-slf4j-impl`），将 SLF4J 的日志调用委托给 Log4j2。

   - 在 Maven 项目中，可以通过以下依赖来实现绑定：

     ```xml
          <dependency>
              <groupId>org.slf4j</groupId>
              <artifactId>slf4j-api</artifactId>
              <version>1.7.30</version>
          </dependency>
          <dependency>
              <groupId>org.apache.logging.log4j</groupId>
              <artifactId>log4j-slf4j-impl</artifactId>
              <version>2.13.3</version>
          </dependency>
          <dependency>
              <groupId>org.apache.logging.log4j</groupId>
              <artifactId>log4j-core</artifactId>
              <version>2.13.3</version>
          </dependency>
          <dependency>
              <groupId>org.apache.logging.log4j</groupId>
              <artifactId>log4j-api</artifactId>
              <version>2.13.3</version>
          </dependency>
     ```

3. **使用 SLF4J 进行日志记录**

- 在代码中使用 SLF4J 的 API 进行日志记录，而具体的日志记录操作由 Log4j2 执行。
- 这种方式使得应用程序与具体的日志框架解耦，可以在不修改代码的情况下切换日志框架。

# 基于SpringBoot的统一日志管理

## 日志框架

>logBack框架Springboot已经内置了，默认采用slf4j+logback,详细配置如上面代码配置

## 创建日志拦截器

为了统一记录请求和响应，创建一个日志拦截器：

```java
@Component
public class LoggingInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(LoggingInterceptor.class);

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.info("Incoming request: {} {}", request.getMethod(), request.getRequestURI());
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        // 可以在这里记录响应信息
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        if (ex != null) {
            logger.error("Request raised an exception", ex);
        }
        logger.info("Outgoing response: {} {}", request.getMethod(), request.getRequestURI());
    }

}
```

## 注册拦截器

在Spring Boot应用中注册这个拦截器,不拦截swagger请求：

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Autowired
    private LoggingInterceptor loggingInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry
                .addInterceptor(loggingInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns(
                "/swagger-resources/**",
                "/swagger-ui.html",
                "/v2/api-docs",
                "/v3/api-docs",
                "/webjars/**"
        );
    }
}

```

## 记录错误信息

为了记录全局的错误信息，可以创建全局异常处理器：

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<String>> handleException(Exception ex) {
        logger.error("Exception occurred: ", ex);
        ApiResponse<String> response = ResponseUtil.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Internal Server Error", ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## 测试

正常会在请求前打印请求信息，结束后也会打印请求信息，出现异常，也会打印异常信息。

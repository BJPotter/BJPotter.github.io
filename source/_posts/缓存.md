---
title: 缓存
tag:
- 系统设计
- 缓存
---

# 多级缓存架构

## 什么是多级缓存架构

多级缓存架构是一种缓存系统，它将缓存分为多个级别，每个级别都有其特定的作用和特点。这种架构的主要目的是提高缓存命中率和系统性能。

## 应用场景

1. **分布式缓存系统**：在分布式系统中，多级缓存架构可以将缓存分配到不同的节点上，提高缓存的可用性和可扩展性。
2. **高性能计算**：在高性能计算中，多级缓存架构可以将缓存分为不同的级别，例如 CPU 缓存、内存缓存和磁盘缓存，提高计算速度和性能。
3. **数据库缓存**：在数据库缓存中，多级缓存架构可以将缓存分为不同的级别，例如一级缓存（内存）和二级缓存（磁盘），提高数据库查询速度和性能。

## 如何实现多级缓存架构

实现多级缓存架构需要考虑以下几个方面：

1. **缓存分配**：将缓存分配到不同的级别上，例如CPU缓存、内存缓存和磁盘缓存。
2. **缓存管理**：管理缓存的生命周期，例如缓存的加载、更新和失效。
3. **缓存命中**：实现缓存命中的机制，例如缓存的查找和替换。

## 原理

多级缓存架构的原理是将缓存分为不同的级别，每个级别都有其特定的作用和特点。例如：

1. **CPU缓存**：CPU 缓存是最快的缓存级别，用于存储常用的数据和指令。
2. **内存缓存**：内存缓存是第二快的缓存级别，用于存储较大的数据和对象。
3. **磁盘缓存**：磁盘缓存是最慢的缓存级别，用于存储大量的数据和文件。

## 优缺点

**优点：**

1. 提高缓存的命中率。
2. 在高性能计算和数据库缓存场景中，提高系统性能。

**缺点：**

1. 引入了多级缓存后，需要进行缓存管理和命中率高的缓存机制，增加了系统复杂性。

2. 引入多级缓存后，需要更多的存储空间，本质上是空间换时间。

## 通用方案

实际中不会使用cpu缓存，这是硬件缓存，一般常用的2级缓存的架构方案，一级缓存：本地缓存`guava`，二级缓存：分布式缓存`redis`。

### Guava VS Redis

**1. Guava**

特点：

+ 内嵌缓存，数据存储在JVM中，适用于单机应用或者本地缓存。

+ 数据存在JVM中，读取和写入时延低。

**2. Redis**

特点：

+ Redis是是一个独立的数据库，可以用作分布式缓存，适用于多个应用实例。
+ 适用于分布式系统、多实例共享数据缓存、可以持久化的数据缓存。

### 为什么Redis稍慢

Guava Cache存储在JVM内存中，所有操作都是本地内存访问，不涉及网络通信。Redis通常作为一个独立的服务运行，应用程序需要通过网络协议（如TCP）进行通信，增加了网络延迟。

### 常见问题

多级缓存架构，能在很多场景下显著提升性能。然而，这种架构也存在一些问题，需要通过特定的方法来解决。

#### 缓存一致性问题

本地缓存和分布式缓存的数据可能不同步，导致缓存数据不一致。比如，当数据在分布式缓存中更新时，本地缓存可能仍然存储旧的数据。

解决方法：

+ **缓存失效策略**：在分布式缓存中更新数据时，立即使相关的本地缓存失效或删除。例如，通过发布/订阅机制（如Redis的Pub/Sub）通知所有应用实例清除或更新其本地缓存。
+ **缓存一致性协议**：使用一致性协议（如基于Zookeeper的分布式一致性算法）来确保缓存一致性，但这种方式复杂度较高。

####  缓存雪崩问题

当缓存中的大量数据同时过期，或者缓存服务器宕机时，所有请求直接涌向数据库，可能导致数据库过载。

解决方法：

+ **缓存预热**：在缓存启动时预加载常用数据，避免大量请求直接打到数据库。

+ **分散过期时间**：为不同的缓存键设置不同的过期时间，避免大量数据同时过期。

+ **降级策略**：在缓存不可用时，采用降级方案，如返回默认值或部分数据。

#### 缓存穿透问题

恶意请求或查询结果不存在的数据直接打到数据库，绕过缓存，导致缓存失效。

解决方法：

+ **缓存空结果**：对于查询结果不存在的数据，也缓存一个空值，但要设置较短的过期时间。

+ **布隆过滤器**：在缓存层之前引入布隆过滤器，快速判断请求的数据是否存在，从而减少对数据库的直接查询。

#### 缓存击穿问题

热点数据在缓存过期的一瞬间，大量请求同时打到数据库，导致数据库压力骤增。

解决方法：

+ **互斥锁/信号量**：在缓存失效时，对同一个键的请求加锁，只有一个请求去加载数据，其余请求等待。
+ **预加载/延迟更新**：在缓存即将过期时，提前加载和更新缓存中的热点数据。

#### 数据一致性问题

当缓存中的数据需要与数据库保持严格一致时，如何处理缓存与数据库的更新操作。

解决方法：

+ **读写穿透**：在更新数据库的同时更新缓存，确保缓存中的数据与数据库一致。
+ **异步更新**：使用消息队列或事件驱动架构，在数据库更新后异步更新缓存。
+ **事务性缓存**：使用分布式事务，确保数据库和缓存更新操作的原子性和一致性。

#### 本地缓存过期问题

本地缓存没有及时更新，可能会存储旧数据。

解决方法：

+ **定期刷新**：定期刷新本地缓存，确保数据不过期。
+ **实时更新**：通过事件驱动机制（如Kafka或Redis的Pub/Sub），在分布式缓存更新时实时通知本地缓存进行更新。

## 示例

### 示例应用架构

+ **本地缓存**：Guava Cache，用于快速访问常用数据。

+ **分布式缓存**：Redis，用于跨实例共享数据。

+ **数据库**：用一个HashMap来模拟数据库。

+ **一致性维护**：使用Redis的Pub/Sub机制通知本地缓存失效。

### 示例代码

#### 依赖

```java
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
<dependency>
   <groupId>com.google.guava</groupId>
   <artifactId>guava</artifactId>
   <version>30.1-jre</version>
</dependency>
```

#### 模拟数据库

```java
public class Database {
    private Map<Long, String> data = new HashMap<>();

    public String getValue(Long key) {
        return data.get(key);
    }

    public void setValue(Long key, String value) {
        data.put(key, value);
    }
}
```

#### 缓存服务

```java
@Component
public class CacheService {

    private Cache<Long, String> localCache;
    private Database database = new Database();

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Autowired
    private RedisMessageListenerContainer redisMessageListenerContainer;

    @PostConstruct
    public void init() {
        // 初始化本地缓存
        localCache = CacheBuilder.newBuilder()
                .maximumSize(100)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .build();

        // 配置Redis的消息监听器，监听"cache:evict"频道
        MessageListenerAdapter listenerAdapter = new MessageListenerAdapter(this, "handleCacheEvict");
        redisMessageListenerContainer.addMessageListener(listenerAdapter, new ChannelTopic("cache:evict"));
    }

    public String getValue(Long key) {
        // 尝试从本地缓存获取
        String value = localCache.getIfPresent(key);
        if (value != null) {
            // 如果本地缓存有数据，但Redis缓存没有数据，将数据回填到Redis缓存
            if (redisTemplate.opsForValue().get("cache:" + key) == null) {
                redisTemplate.opsForValue().set("cache:" + key, value);
            }
            return value;
        }

        // 尝试从分布式缓存获取
        value = redisTemplate.opsForValue().get("cache:" + key);
        if (value != null) {
            // 将数据更新到本地缓存
            localCache.put(key, value);
            return value;
        }

        // 最后从数据库获取
        value = database.getValue(key);
        if (value != null) {
            localCache.put(key, value);
            redisTemplate.opsForValue().set("cache:" + key, value);
        }
        return value;
    }

    public void setValue(Long key, String value) {
        // 更新数据库
        database.setValue(key, value);

        // 更新缓存
        localCache.put(key, value);
        redisTemplate.opsForValue().set("cache:" + key, value);

        // 通知其他实例的本地缓存失效
        redisTemplate.convertAndSend("cache:evict", key.toString());
    }

    // 处理缓存失效的通知
    public void handleCacheEvict(String key) {
        localCache.invalidate(Long.parseLong(key));
    }
}
```

#### 配置Redis

```java
@SpringBootApplication
public class CacheApplication {

    public static void main(String[] args) {
        SpringApplication.run(CacheApplication.class, args);
    }

    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        return template;
    }

    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(RedisConnectionFactory connectionFactory) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        return container;
    }
}
```

#### 进行数据操作

```java
@Component
public class CacheRunner implements CommandLineRunner {

    @Autowired
    private CacheService cacheService;

    @Override
    public void run(String... args) throws Exception {
        // 设置值
        cacheService.setValue(1L, "Value1");

        // 获取值
        String value = cacheService.getValue(1L);
        System.out.println("Get value for key 1: " + value);

        // 更新值
        cacheService.setValue(1L, "UpdatedValue1");

        // 再次获取值，应该是更新后的值
        value = cacheService.getValue(1L);
        System.out.println("Get updated value for key 1: " + value);
    }
}
```

#### 代码流程

**初始化本地缓存**：

- 使用Guava Cache构建一个本地缓存。
- `maximumSize`设置缓存最大条目数。
- `expireAfterWrite`设置缓存条目的过期时间。

**消息监听器**：

- 使用Spring的`RedisMessageListenerContainer`监听Redis的Pub/Sub频道`cache:evict`。
- 当有消息发布到`cache:evict`频道时，`handleCacheEvict`方法将被调用，失效本地缓存中的相应条目。

**数据获取**：

- `getValue`方法首先尝试从本地缓存获取数据，如果本地缓存没有命中，再尝试从Redis缓存获取，如果redis命中了，做一个缓存回填，否则从数据库获取。
- 如果数据从数据库获取成功，会同时更新本地缓存和Redis缓存。

**数据设置**：

- `setValue`方法更新模拟数据库的数据，同时更新本地缓存和Redis缓存。
- 通过`redisTemplate.convertAndSend`方法，将缓存失效通知发布到`cache:evict`频道，通知其他实例失效相应的本地缓存。

**处理缓存失效通知**：

- `handleCacheEvict`方法负责处理从`cache:evict`频道接收到的消息，失效本地缓存中的相应条目。

# 缓存淘汰

## 缓存替换策略有哪些

> 缓存是常用的技术手段，它能够帮助我们更快地获取频繁使用的数据。不过当缓存满了以后，我们就需要选择某种策略来决定谁将从缓存中被优先移除。以下是一些常见的缓存替换策略及其实现。

1. **LRU (Least Recently Used)**

LRU是最近最少使用的缓存策略，它以时间为依据，优先替换最长时间未访问的数据。这是基于这样一个理论：如果一个数据最近被访问过，那么它在未来被再次访问的可能性很高。我们可以通过维护一个所有缓存条目的链表来实现这个策略。当一个条目被访问时，我们将其移到链表的顶部。当需要逐出数据时，移除链表尾部的条目。

2. **MRU (Most Recently Used)**

MRU是与LRU恰恰相反的策略，它优先替换最近访问的数据。MRU假设最近访问过的数据在未来最不可能被访问，这在很多场景都是合理的。其实现与LRU类似，但当条目被访问时，我们将其移到链表的底部，而非顶部。替换时，我们移除链表顶部的项。

3. **SLRU (Segmented LRU)**

SLRU是LRU的进阶版，它将缓存分为两个部分：probation（试用）和protected（保护）。新来的数据先进入probation部分，如果再次被访问则会被推到protected部分。当需要替换数据时，首先替换probation部分的，如果probation部分为空，那么从protected部分挤出一部分数据。

4. **LFU (Least Frequently Used)**

LFU策略会优先替换那些访问次数最少的数据。实现LFU需要我们追踪每个条目被访问的频率，这可以通过哈希表实现。每当条目被访问，其计数就增加，当缓存满时，只需将计数最小的条目移除即可。

5. **FIFO (First In, First Out)**

FIFO的策略很简单：先进入缓存的数据首先被替换。实现FIFO可以通过队列实现，新的条目添加到队尾，替换时移除队首条目。

6. **TTL (Time To Live)**

TTL是一个时间相关的策略。在TTL策略中，缓存条目有一个剩余生命期，当生命期到达就将其从缓存中移除。这就意味着所有的缓存条目都有一个过期时间。

7. **双层缓存**

在某些情况下，我们可能需要两层缓存：一层是在CPU里面，另一层在内存中。CPU层的缓存很小但是非常快速，内存层的缓存则大很多但是速度慢一些。数据首先从CPU缓存中获取，如果没有再去内存缓存中获取。对于这种策略，我们可以为每层都使用适合的策略，比如LRU等。

8. **RR (Random Replacement)**

RR是最简单的一种缓存替换策略，它随机选择一个条目进行替换。实现RR策略则只需要在所有的缓存条目中随机选一个移除即可。

## 缓存替换策略实现算法

1. **LRU (Least Recently Used)**

   最简单的实现方式是使用一个队列和一个哈希表。队列用于保存元素的访问顺序，哈希表用于查找元素是否在队列中。每次使用某个元素时，将它添加到队列尾部或移动到队列尾部。当队列满时，队列头部的元素就是最长时间未被使用的元素，将其弹出。

2. **MRU (Most Recently Used)**

   MRU的实现方式与LRU类似。区别是每次使用某个元素时，将它添加到队列头部或者移动到队列头部。当队列满时，移除队列尾部的元素。

3. **SLRU (Segmented LRU)**

   SLRU具体实现可以借助两个队列：一个用于保护段（protected segment），一个用于试验段（probational segment）。新元素首先添加到试验段队列尾部。当元素再次被访问时，它被移到保护段队列尾部。如果试验段队列满，移除它的头部元素。如果保护段队列满，将头部元素移到试验段队列尾部。

4. **LFU (Least Frequently Used)**

   LFU可以通过优先队列和哈希表来实现。哈希表用于查找元素，优先队列用于保存访问频率和元素的对应关系。每次访问元素，都会更新其在优先队列中的优先级。当需要替换元素时，移除优先队列顶部的元素。

5. **FIFO (First In, First Out)**

   FIFO是最简单的策略，也是通过队列实现。新元素直接添加到队列尾部，需要替换时直接丢弃队列头部的元素。

6. **TTL (Time To Live)**

   TTL可以通过每个元素添加一个时间戳来实现。每次访问队列时，检查队列头部的元素，如果它们的有效期已经过期，就将它们出队。

7. **双层缓存**

   双层缓存的实现需要两个缓存，每个缓存都使用适当的替换策略，比如LRU或者FIFO。第一级缓存通常位于CPU中，非常小但速度很快。第二级缓存位于内存中，较大但速度较慢。

8. **RR (Random Replacement)**

   RR可能是最简单的缓存替换策略，每次替换时，从缓存中随机选择一个元素丢弃。
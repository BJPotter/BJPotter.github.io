---
title: java基础-JVM
tag:
- java
---

# JVM基础

## JVM的主要组成部分及其作用

1. **类加载器（ClassLoader）**：负责加载Java类文件，将其转化为JVM能够识别的Class对象。
2. **运行时数据区（Runtime Data Area）**：JVM在执行Java程序时会使用到的数据区，包括方法区、堆、虚拟机栈、本地方法栈和程序计数器。
3. **执行引擎（Execution Engine）**：负责执行字节码，包括解释器、即时编译器（JIT）和垃圾回收器等。
4. **本地接口（Native Interface）**：JNI（Java Native Interface）允许Java代码与其他编程语言（如C/C++）编写的代码进行交互。

## JVM运行时数据区

1. **方法区（Method Area）**：存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等数据。
2. **堆（Heap）**：存放对象实例和数组，是GC主要管理的区域。
3. **虚拟机栈（Java Virtual Machine Stack）**：存放每个线程的栈帧（方法调用过程中的局部变量表、操作数栈、方法返回地址等）。
4. **本地方法栈（Native Method Stack）**：为本地方法服务，与虚拟机栈类似。
5. **程序计数器（Program Counter Register）**：当前线程执行的字节码的行号指示器。

## 深拷贝和浅拷贝

- **浅拷贝**：复制对象时只复制对象的引用，不复制对象本身。
- **深拷贝**：复制对象时，除了复制对象的引用，还复制对象本身及其包含的所有对象。

## 堆和栈的区别

- **堆**：用于存储对象实例，线程共享，生命周期较长，由GC管理。
- **栈**：用于存储局部变量、方法调用等，线程私有，生命周期较短，方法执行完自动释放。

## 队列和栈是什么？有什么区别？

- **队列（Queue）**：FIFO（先进先出）数据结构，元素从尾部插入，从头部删除。
- **栈（Stack）**：LIFO（后进先出）数据结构，元素从顶部插入和删除。

# HotSpot虚拟机对象探秘

## 对象的创建

- **类加载检查**：检查类是否已加载，未加载则加载类。
- **分配内存**：在堆中为对象分配内存，使用指针碰撞或空闲列表。
- **初始化**：对分配的内存进行零值初始化。
- **设置对象头**：初始化对象的元数据信息。
- **执行构造方法**：调用<init>方法进行初始化。

## 为对象分配内存

- **指针碰撞**：适用于内存规整的堆，通过移动指针分配内存。
- **空闲列表**：适用于内存不规整的堆，通过维护空闲列表分配内存。

## 处理并发安全问题

- **CAS**：通过乐观锁的方式解决并发问题。
- **TLAB**：每个线程分配一个本地缓冲区（Thread Local Allocation Buffer）进行内存分配。

## 对象的访问定位

- **句柄访问**：对象引用存储的是句柄地址，句柄中包含对象实例数据和类型数据的指针。
- **直接指针**：对象引用存储的是对象实例的直接地址。

# 内存溢出异常

## Java会存在内存泄漏吗？请简单描述

Java中也会存在内存泄漏，例如，长生命周期对象持有短生命周期对象的引用，导致短生命周期对象无法被GC回收。

# 垃圾收集器

## 简述Java垃圾回收机制

Java的垃圾回收机制通过GC自动回收不再使用的对象，主要算法包括标记-清除、复制和标记-整理等。

## GC是什么？为什么要GC

GC（Garbage Collection）是垃圾回收的缩写，自动管理内存，防止内存泄漏，提高程序稳定性和性能。

## 垃圾回收的优点和原理。并考虑2种回收机制

- **优点**：自动内存管理，减少内存泄漏，提高开发效率。
- **标记-清除**：标记所有存活对象，清除未标记的对象。
- **复制**：将存活对象复制到新空间，清除旧空间。

## 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

垃圾回收器通过跟踪对象的引用链，回收不可达的对象。垃圾回收器不能马上回收内存，可通过`System.gc()`或`Runtime.getRuntime().gc()`主动通知进行垃圾回收。

## Java中都有哪些引用类型？

- **强引用**：不会被GC回收。
- **软引用**：内存不足时会被回收。
- **弱引用**：在GC时会被回收。
- **虚引用**：无法通过引用访问对象，仅用于监控对象的回收。

## 怎么判断对象是否可以被回收？

通过引用计数或可达性分析算法判断对象是否可达，不可达的对象可以被回收。

## 在Java中，对象什么时候可以被垃圾回收？

当对象没有任何强引用时，可以被垃圾回收。

## JVM中的永久代中会发生垃圾回收吗？

在JDK 8之前，永久代中会发生垃圾回收，但频率较低。JDK 8以后，永久代被移除，替代为元空间（Metaspace）。

## 说一下JVM有哪些垃圾回收算法？

- **标记-清除算法**：标记存活对象，清除未标记对象。
- **复制算法**：将存活对象复制到新空间，清除旧空间。
- **标记-整理算法**：标记存活对象，将存活对象移动到一端，清除剩余空间。
- **分代收集算法**：将堆分为新生代和老年代，分别使用不同的垃圾回收算法。

## 说一下JVM有哪些垃圾回收器？

- **Serial收集器**：单线程收集，适用于单CPU环境。
- **Parallel收集器**：多线程收集，适用于多CPU环境。
- **CMS收集器**：低停顿时间的并发收集器，适用于低停顿需求的应用。
- **G1收集器**：面向服务端应用，适用于大内存、多CPU环境。

## 详细介绍一下CMS垃圾回收器？

- **初始标记**：标记GC Roots可达的对象，短暂停顿。
- **并发标记**：标记所有可达对象，不停顿。
- **重新标记**：修正并发标记期间的变动，短暂停顿。
- **并发清除**：清除不可达对象，不停顿。

## 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？

- **新生代垃圾回收器**：Serial、ParNew、Parallel Scavenge。特点是频繁回收、停顿时间短。
- **老年代垃圾回收器**：Serial Old、CMS、Parallel Old。特点是回收频率低、停顿时间长。

## 简述分代垃圾回收器是怎么工作的？

分代垃圾回收器将堆划分为新生代和老年代。新生代对象生命周期短，频繁回收；老年代对象生命周期长，较少回收。回收时，新生代使用复制算法，老年代使用标记-整理或CMS。

# 内存分配策略

## 简述java内存分配与回收策略以及Minor GC和Major GC

- **内存分配**：对象优先在Eden区分配，大对象直接进入老年代，长期存活对象进入老年代。
- **Minor GC**：针对新生代的垃圾回收，频繁但耗时短。
- **Major GC**：针对老年代的垃圾回收，频率低但耗时长。

## 对象优先在Eden区分配

大多数新创建的对象在Eden区分配，当Eden区满时触发Minor GC，将存活对象移到Survivor区。

## 大对象直接进入老年代

避免在新生代频繁复制大对象，减少内存复制开销。

## 长期存活对象将进入老年代

对象在Survivor区经历多次GC后，晋升到老年代。

# 虚拟机类加载机制

## 简述java类加载机制


Java类加载机制包括加载、链接和初始化三个步骤。加载阶段通过类加载器读取类文件，将其转化为二进制数据；链接阶段验证、准备和解析类；初始化阶段执行类的静态初始化器和静态变量初始化。

## 描述一下JVM加载Class文件的原理机制

JVM通过类加载器加载Class文件，加载过程包括查找和加载Class文件，将其转化为Class对象。加载器遵循双亲委派模型，保证类加载的安全性和一致性。

## 什么是类加载器，类加载器有哪些?

类加载器是负责加载类文件的组件，主要有以下几种：
- **启动类加载器（Bootstrap ClassLoader）**：加载JDK核心类库。
- **扩展类加载器（Extension ClassLoader）**：加载扩展类库。
- **应用程序类加载器（Application ClassLoader）**：加载应用程序类。
- **自定义类加载器**：用户定义的类加载器。

## 说一下类装载的执行过程？

类装载的执行过程包括：
1. **加载**：通过类加载器读取类文件。
2. **链接**：包括验证、准备和解析三个阶段。
3. **初始化**：执行类的静态初始化器和静态变量初始化。

## 什么是双亲委派模型？

双亲委派模型是指类加载时，类加载器先委托父类加载器加载，父类加载器无法加载时，子类加载器再尝试加载。这保证了类的加载安全和统一。

# JVM调优

## 说一下JVM调优的工具？

常用的JVM调优工具包括：
- **jstat**：监控JVM内存和垃圾回收情况。
- **jmap**：生成堆转储快照，分析内存使用情况。
- **jstack**：生成线程快照，分析线程状态。
- **VisualVM**：图形化界面监控JVM性能。

## 常用的JVM调优的参数都有哪些？

- **-Xms**：设置初始堆大小。
- **-Xmx**：设置最大堆大小。
- **-Xmn**：设置新生代大小。
- **-XX:PermSize**：设置初始永久代大小（JDK 8前）。
- **-XX:MaxPermSize**：设置最大永久代大小（JDK 8前）。
- **-XX:MetaspaceSize**：设置初始元空间大小（JDK 8后）。
- **-XX:MaxMetaspaceSize**：设置最大元空间大小（JDK 8后）。
- **-XX:+UseG1GC**：使用G1垃圾回收器。
